## 本章目標
>區分出序向電路與組合電路，並在這個章節探討序向電路之應用

## 目錄
* [A1. 前言與聲明](#A1)
* [1. 序向電路](#1)
* [2. 儲存元件：閂鎖器](#2)
* [3. 儲存元件：正反器](#3)
* [4. 時控序向電路分析](#4)
* [5. 狀態簡化與指定](#5)
* [6. 設計程序](#6)
* [A2. 單字對證](#A2)
* [A3. 後記與參考](#A3)

<h2 id = "A1"> A1. 前言與聲明 </h2>
在進入數位邏輯設計的同時，也意味著你將要開始以數位世界的思維與規則在思考各種觀念與問題，
 
請整理好思緒，別讓自己前後矛盾而混淆了許多簡單的觀念。另有以下幾點聲明須知：

* 本教學歡迎轉載分享，唯獨不得做為商業利益使用，內容援引之範例，其版權皆屬原作者所有
* 講義內容之安排係以國立臺北教育大學數位科技設計學系安排之課程內容為主，若有未提及之處，請善用網路資源
* [A2. 單字對證](#A2)中對於各項專有名詞之名稱將以參考書目為準，若有疑問，請善用網路資源
* 參考書目及其他援引資訊將列於[A3. 後記與參考](#A3)


<h2 id = "1"> 1. 序向電路 </h2>

* 此章節之前的探討皆為組合邏輯電路 ─ 亦即它們的輸出會立即隨著當下的輸入而改變
* 序向電路如同儲存元件，具有記憶
* 序向電路可以儲存、保留，以及在稍後的時間點，將需要的資訊取回

---

一個序向電路的方塊圖如下：  
![File Crash!](https://i.imgur.com/Ycu1MOA.jpg)  

上圖包含一個組合邏輯電路及儲存元件，其中儲存元件可以儲存二元資料，並連接到組合邏輯電路，形成一個**回授路徑**  
儲存在這些元件的二元資料即可用來定義序向邏輯電路在任一特定時間時的狀態  

序向邏輯電路從 **外部輸入(方塊圖最左端)** 獲取二元資料，這些輸入訊號連同儲存元件當下的狀態，可以決定輸出的二元數值  
※當然，這些外部輸入也會決定儲存元件中狀態改變的情形

上圖說明序向電路的**輸出(方塊圖最右端)**，能影響它的並不只有外部輸入，還取決於儲存元件的**目前狀態(present state)**  
此外，儲存元件的次一狀態(next state)也是外部輸入和目前狀態的函數  

<pre>
搭配圖片說明的話
「目前狀態」就是記憶元件方塊的輸出~組合邏輯電路方塊的輸入這一段
「次一狀態」就是組合邏輯電路方塊的輸出~記憶元件方塊的輸入這一段

其中，要輸出「次一狀態」給記憶元件的話，會先經過組合邏輯電路內部的操作，而這時作為組合邏輯電路的輸入正是「外部輸入」以及「目前狀態」
</pre>

總而言之，**序向電路是一個由輸入、輸出，以及其內部狀態的時序來描述的電路**

序向電路有兩種主要的類型，分辨方式由**信號的時序**而定  
**同步序向電路(synchronous sequential circuit)** 的動作可由它的不連續之瞬時信號來決定的系統；  
**非同步序向電路(asynchronous sequential circuit)** 的動作取決於瞬時的輸入信號及信號改變的次序  
※一般來說，使用於非同步序向電路的儲存元件稱為延時(time-delay)  

<pre>
延時裝置的儲存能力取決於信號傳輸通過元件所需的時間
實際應用方面，邏輯閘本身內部的傳輸延遲就足以產生足夠的延遲時間，所以或許可以不用實際的延時單元

因此，假設一個非同步序向電路移除了延時裝置(儲存元件)，就可以視為一個具有回授路徑的組合邏輯電路
但是這種邏輯閘之間的回授，走時候會讓這個電路不穩定，造成設計人員在開發上的困難，故不深入探討
</pre>

一個同步序向電路僅在某些不連續的時間點利用會影響儲存元件的信號  
利用產生一連串週期性時脈脈波(clock pulses)的計時裝置，稱之為時脈產生器(clock generator)，便可讓時間同步化  

時脈信號通常用 *clock* 或 *clk* 來表示
整個電路系統都會使用到脈波，但是儲存元件僅會在每一脈波抵達時才會受到影響，而其它信號則是決定會發生什麼改變

<pre>
舉例來說，現在有一個算式是5+6=?
那麼時脈脈波將會決定「何時要計算出結果」
而其它輸入(如5跟6)，就是決定「輸出的內容」，也可說是「改變後得到的結果」

至於加號，則可以視為邏輯電路欲達到的功用
</pre>

同步序向電路利用時脈來控制儲存元件，稱為**時脈序向電路(clock sequential circuits)**。實際上，這也是最常使用的形式  

他們之所以可以被稱為同步電路，就是因為電路的動作與其所造成的儲存值之更新，都會**與時脈產生的瞬間同步化**  

同步電路很少出現不穩定的狀況，甚至可以將它分解成可個別考慮之獨立的不連續信號  

使用在時脈序向電路的儲存元件稱為**正反器(flip-flop)**，可以用來儲存一個位元的資料，穩定狀態下的輸出會是0或1  
※一個序向電路可使用多個正反器來儲存需要的位元資料，只是本節範例圖為求簡潔，只保留一個

下圖便是一個時脈序向電路的方塊圖：  
![File Crash!](https://i.imgur.com/a6xKNxt.jpg)  

輸出的內容可以是下面幾種：  
1. 電路各輸入之組合邏輯函數  
2. 儲存在正反器內的值  
3. 上述兩者所形成

儲存在正反器內的值在時脈發生時，也會由電路的輸入，或正反器目前所儲存的值(或上述兩者同時影響)來決定改變與否  

時脈信號發生時，新值會被儲存(即更新正反器)  
在下一次時脈產生之前，形成正反器次一狀態的組合邏輯**必須先達到穩定狀態之值**  
也就是說，**組合邏輯電路的執行效率非常重要！**  

以上圖為例，如果(同步化的)時脈以規律的時間間隔抵達時，則在下一個脈波抵達以前，
組合邏輯電路必須對即將被更新之值正反器的狀態變動做出反應  

為了讓電路可以正確操作，在決定時脈產生的最小時間間隔的時候，(組合邏輯電路之邏輯閘的)傳播延遲是一個很重要的因素  

<pre>
正反器的狀態改變只能由時脈轉變來啟動，例如，時脈信號值從0轉為1時

當時脈沒有動作(狀態改變)時，正反器的輸出就無法改變，也因為上面的緣故，正反器所儲存的值與正反器輸入處所形成的值之間形同「斷路」

因此，從**某一狀態(目前狀態)~次一狀態的改變**，只會發生於**時脈脈波所欲先指定的時間區間**
</pre>




<h2 id = "2"> 2. 儲存元件：閂鎖器 </h2>

* 不同形式的儲存元件，差別在於它們具有的輸入總數不同及輸入影響二元狀態的方式不同
* 對信號準位操作(而非信號轉態)之儲存元件，稱為閂鎖器(latches)
* 可由時脈轉態加以操控的儲存元件，稱為正反器(flip-flop)

---
閂鎖器又稱之為準位感測裝置(level-sensitive devices)；正反器則稱為邊緣感測裝置(edge-sensitive devices)  

閂鎖器是所有正反器組成的基本電路  
雖然閂鎖器用來儲存二元資訊相當有用，也可用來設計非同步序向電路，但是作為同步序向電路的儲存元件時卻不實用  
但是既然作為正反器的建構方塊，因此在探討正反器之前，下面將對於閂鎖器的種類做基本介紹

---
SR閂鎖器是由兩個交連的NOR閘或NAND閘所組成  
有兩個輸入端，分別為*S* ─ 設置輸入； *R* ─ 重置輸入，基本的SR閂鎖器與函數表如下圖所示：  
![File Crash!](https://i.imgur.com/yGsGyRr.jpg)   

上面的閂鎖器有兩個有作用的狀態：
當*Q* = 1且*Q'* = 0時，此閂鎖器處於設置狀態(set state)  
當*Q* = 0且*Q'* = 1時，此閂鎖器處於重置狀態(reset state)  

<pre>
一般而言，輸出Q與Q'之間互為補數
倘若兩個輸入同時為1，會導致兩個輸出皆為0
之後如果兩個輸入同時為0，裝置將會進入一個不穩定，不可預期的狀態，稱為未定義的次一狀態(undefined next state)
同時破壞兩個輸出互為補數的規定

因此，在實際應用方面，同時輸入1是被禁止的
</pre>

一般情況下，除非必須改變狀態，否則閂鎖器的兩個輸入將保持為0  

當1瞬間被輸入至*S*端，則閂鎖器進入設置狀態  
為**避免形成未定義狀態**(兩輸入皆為1)，必須先讓S端變回0，如上面的函數表所示  

有兩個輸入狀況會讓電路呈現設置狀態，一個自然是*S* = 1，*R* = 0，屬於 **「改變輸入，讓電路進入設置狀態」**  
另一個是將*S* 從1回歸0，屬於**「讓電路保持設置狀態」**  

當兩個輸入皆回歸0以後，再將1輸入至*R*端，使閂鎖器進入重置狀態  
接著將*R* 從1回歸0，則電路繼續保持重置狀態  

換言之，當*S*與*R* 同時為0時，判斷閂鎖器處於設置或重置狀態的方法，就**取決於哪一個輸入端先成為1**  

下圖是用NAND閘完成的*SR*閂鎖器與函數表：  
![File Crash!](https://i.imgur.com/34xF2M8.jpg)

使用上與NOR閘的*SR*閂鎖器大同小異：  
除非必須改變狀態，否則閂鎖器的兩個輸入將保持為1  
當0瞬間被輸入至*S* 端，則閂鎖器進入設置狀態  
為**避免形成未定義狀態**(兩輸入皆為1)，必須先讓*S* 端變回1，如上面的函數表所示  
當兩個輸入皆回歸1以後，再將0輸入至*R* 端，使閂鎖器進入重置狀態  
接著將*R* 從0回歸1，則電路繼續保持重置狀態  

整體來說就是NOR閘的輸入方式顛倒過來，也因此，偶爾會被稱為*S'R'* 閂鎖器(加上一撇類似補數，也有在字母上方加橫線的表示方法)  
同時，對於*S'R'* 閂鎖器來說，兩個輸入端同時為0是禁止的，會造成未定義的次一狀態  

如果能夠利用一個額外的輸入信號，就可以修正*SR*閂鎖器的基本操作  
藉由判定*S* 與 *R* (或*S'*與*R'*)可以影響電路，這種額外輸入可以控制閂鎖器的狀態**何時可改變**

具有控制輸入的*SR*閂鎖器與函數表如下圖：  
![File Crash!](https://i.imgur.com/67q9cr9.jpg)  

是由NAND閘之*SR*閂鎖器，搭配額外的兩個NAND閘以及一個致能( *En* )輸入完成  
只要致能輸入維持在0，則左半部的兩個NAND閘將持續輸出1，對於*SR*閂鎖器來說，這是一種靜止狀態  
唯有致能輸入為1時，*S*與*R*端才會真正影響到閂鎖器的輸出  

對應的函數表可以在上圖中查詢，當*S* = 1，*R* = 0,*En* = 1時，閂鎖器將會是設置狀態；*S* = 0，*R* = 1,*En* = 1時，閂鎖器就是重置狀態  

上述兩種情況下，若*En*變為0，則電路將會維持當下的狀態，因為 *En* = 0時，電路處於禁能，無法加以改變狀態  
當然，就算*En* = 1，但是*S*與*R* 皆為0時，電路一樣不會改變，這點與前面的閂鎖器相同  

<pre>
所以加上致能就可以解決所有閂鎖器的問題嗎？答案是否定的
當三個輸入(S,R,En)皆為1時，電路同樣會形成未定義狀態，同樣會造成電路處理的困難，因此很少被實用

儘管如此，這還是一個重要電路，因為其他有用的閂鎖器與正反器是以它為基礎製作而成
</pre>

---
要排除*SR*閂鎖器發生未定義狀態的方法是存在的，只要確保*S*與*R*不可能同時為1即可  
這樣的想法可以由下圖的*D*型閂鎖器來完成：  
![File Crash!](https://i.imgur.com/eblBA4E.jpg)  

輸入*D*為資料(Data)，進入上方NAND閘的線路可視作 *S* 端，轉為*D'* 再下方進入NAND閘則可視作*R*端  

同樣的，當 *En* = 0時，左半部的兩個NAND閘之輸出將會以1準位進入SR閂鎖器，電路狀態也就不會改變  
反之，當*En* = 1且 *D* = 0時，*Q* = 0，電路為重置狀態；當*En* = 1且 *D* = 1時，*Q* = 1，電路為設置狀態  

*D*型閂鎖器具有將資料保存在它內部記憶體的能力，適合作為一單元與其環境之間二元資料的暫存  
當致能被確認時，出現在*D* 型閂鎖器的輸入端之二元資料即被傳送到*Q*輸出端  

只要致能輸入被確認，輸出即會隨著輸入的資料而改變  
這種如同直接提供輸入 *D*到輸出的路徑，也讓這個電路被稱作**透明閂鎖器(transparent latch)**  

當電路被禁能( *En* = 0 )時，資料輸入端的二元資料在轉態發生時會被保留(即儲存)在*Q*輸出端  
直到致能輸入被確認( *En* = 1 )時，值才會被改變  

下面是三種閂鎖器的方塊圖符號：  
![File Crash!](https://i.imgur.com/aFOUMnS.jpg)  

輸入在左端，而輸出在右端  
其中輸出端的其中之一有小圓泡，此即補數輸出(上述幾個範例中的 *Q'*)  

*SR*閂鎖器與*D* 型閂鎖器的電路都涵蓋在方塊圖內  
而NAND閘的*SR*閂鎖器，若在輸入端加上小圓泡，就表示閂鎖器利用邏輯0信號(或負邏輯)來進行重置與設置操作



<h2 id = "3"> 3. 儲存元件：正反器 </h2>

* 一個閂鎖器或正反器的狀態是隨控制輸入的改變而改變，這種瞬時(momentary)改變稱為觸發(trigger)
* 由觸發而引起的轉變被稱為正反器的觸發

---
由前面的例子可以得知， **序向電路(sequential circuit)** 有一個回授路徑，從正反器的輸出連接至組合電路的輸入端  
因此，正反器的一部分輸入是從本身或是其他正反器的輸出而來  

前面有提及，閂鎖器被用來當作儲存元件時相當不實用，一旦時脈轉變為邏輯1準位時，閂鎖器的狀態也會立刻轉變  
當時脈維持原狀，閂鎖器的輸出會誕生新的狀態  

這個輸出會經由組合電路連接到閂鎖器輸入端 **(注意：此時閂鎖器能維持邏輯1準位)**

如果此時連接到閂鎖器的輸入有所改變，則閂鎖器會產生新值以及新的輸出狀態，這也將是一個不可預測的結果  
因為只要時脈維持在有效準位(致能)，閂鎖器的狀態就有可能一直改變  

因為上述的原因，如果所有的閂鎖器都共用一個時脈時，閂鎖器的輸出不能直接(或間接)經由組合電路連接至同一個(或其他)閂鎖器的輸入  

正反器的製作方式係要能**讓利用相同時脈的序向電路能夠正確運作**    
閂鎖器的問題在於 ─ 它會隨著時脈準位(level)改變而改變，如下圖(a)所示  
![File Crash!](https://i.imgur.com/46OhisA.jpg)  

以(a)為例，若時脈持續停留在邏輯1，當*D*的輸入值改變時，在致能輸入端的 **正準位響應(positive level response)**將允許輸出改變  

對正反器正確操作來說，重點在於只需要在**信號轉變**時觸發它，可透過消除使用閂鎖的序向電路之內部回授電路操作來完成  

時脈信號會有兩種轉變方式：
第一種 ─ 從0到1  
屬於正轉變，如上圖(b)所示，也稱為**正緣(positive-edge)**  


第二種 ─ 從1到0
屬於負轉變，如上圖(c)所示，也稱為**負緣(negative-edge)**  

有兩種方式可以將閂鎖器修正成正反器：  
第一種 ─ 用兩個閂鎖器形成特殊結構，藉此隔離正反器的輸出，避免在轉變過程中相互影響  
第二種 ─ 製作只能在信號轉變(從0到1；從1到0)時觸發，其餘時脈期間禁能的正反器  

---
由兩個*D* 型閂鎖器和一個反相器所組成的*D* 型正反器如下圖所示：  
![File Crash!](https://i.imgur.com/BefKGNG.jpg)  

第一個閂鎖器稱為**主閂鎖器(master latch)**；第二個閂鎖器稱為**僕閂鎖器(slave latch)**  
此電路只有在同步或控制時脈(*Clk*)的負緣才會取出*D* 輸入並改變*Q*輸出  

當*Clk* = 0時，反相器的輸出為1，僕閂鎖器被致能，並且它的輸出*Q* 等於主閂鎖器的輸出*Y* **(注意：此時主閂鎖器處於禁能狀態)**

當*Clk* 改為1時，外部*D* 輸入的資料會被傳送到主閂鎖器，但是只要時賣持續處於1準位，僕閂鎖器就會被禁能  
換言之，此時只有主閂鎖器在運作且改變輸出*Y*，僕閂鎖器甚至更之後的輸出*Q* 毫無影響  

此時*Clk* 再從1變回0，那麼主閂鎖器禁能，而僕閂鎖器便可以取得改變後的 *Y* 並輸出成*Q*  
因此，只有在時脈由1轉為0，正反器的輸出才會被觸發改變 **(負緣響應)**  

<pre>
統整上面的敘述：
(1) 只有在時脈負緣時，輸出才會改變一次
(2) 由時脈的負緣觸發，輸出改變一次
(3) 只有在時脈為負值期間，可能發生改變
</pre>

正反器輸出所產生的值就是 **時脈負緣要發生的前一瞬間，儲存在主閂鎖器之值，即Y**  
當然，我們也可以設計一個正緣響應的正反器，只要再多補上一個反相器即可  

另一種邊緣觸發*D* 型正反器是由三組*SR* 閂鎖器所組成，如下圖所示：  
![File Crash!](https://i.imgur.com/3UcixHM.jpg)  

其中左半部的兩組閂鎖器對於外部輸入*D* (資料)與 *Clk* (時脈)有反應，第三組閂鎖器則提供正反器輸出  
以下按照發生順序說明：  

1. 當*Clk* = 0時，輸出閂鎖器的*S* 和*R* 則維持邏輯1，讓輸出維持目前狀態  
2. 輸入*D* 可以是0或1，當*Clk* 轉變為1且*D* = 0時，*R* 會轉變為0，使裝置進入重置狀態，*Q* = 0  
3. 當*Clk* = 1，而輸入*D* 有所改變時，因為*Q*仍然為0，故*R* = 0，因此正反器被鎖住，不會對輸入產生反應  
4. 接著*Clk* 回歸0，*R*會變成1，使右邊的輸出用閂鎖器處於靜態狀況，輸出也不會有變化  
5. 若*D* = 1，當 *Clk* 由0轉為1時，*S* 變為0，電路進入設置狀態，且*Q* = 1  

※當 *Clk* = 1時，*D*的任何改變都不會影響輸出  

總而言之，當正緣觸發正反器的輸入時脈有**正轉變(positive transition)時**，則*D* 的值會被傳送到*Q*  
時脈由1變為0(負轉變)時則不影響輸出  
此外，當*Clk* 處於穩定狀態(不論是1或0)時，*D* 的改變同樣也不會造成輸出變化  

在使用編緣觸發正反器時，必須將正反器對輸入資料及對時脈的**反應時序(timing of the response)**加以考量  
有一最小時間，稱為**設定時間(setup time)** ，即在時脈發生改變之前，輸入*D* 必須維持在一常數值的時間  

同樣地，有另一個最小時間稱為**保持時間(hold time)**，即在加入時脈的正轉變之後，輸入*D*必須維持不變的時間  

正反器的**傳播延遲時間(propagation delay time)**被定義為介於「觸發邊緣」和「穩定之新輸出狀態」兩者的**時間間隔(time interval)**  

下圖代表一個邊緣觸發*D* 型正反器的方塊圖：  
![File Crash!](https://i.imgur.com/aAFwR5b.jpg)  

比較需要注意的是，在*Clk* 前加上一個箭頭符號代表**動態(dynamic)** ，其他部分則與閂鎖器相似  
這個**動態標誌(dynamic indicator)** 代表正反器採邊緣觸發方式，**動態標誌的前面有無小圓泡將決定這個正反器採用的是正緣或是負緣觸發**  

---
最經濟且效率的正反器為*D* 型邊緣觸發正反器，但這不代表沒有其他形式的正反器  
以*D* 型邊緣觸發正反器為基礎，可以衍生出*JK* 正反器和*T* 型正反器  

正反器可以執行三種動作(operation)：設置為1、重置為0、輸出的補數  

*D* 型正反器由於只有單一輸入，只能夠設置與重置輸出，主要依據時脈轉變之前一瞬間的*D* 輸入而定  

但是因為同步的時脈信號，因此具有兩個輸入的*JK* 正反器可以執行三種以上的動作  
下圖就是由*D* 型正反器與邏輯閘組成的*JK* 正反器示意圖：  
![File Crash!](https://i.imgur.com/qXB4j3T.jpg)  

*J* 輸入可以設置正反器為1；*K* 輸入可以重置正反器為0  
而兩輸入被致能時，輸出則變為補數，這一行描述可以由加至*D* 輸入端之電路方程式確認：  
*D* = *JQ'* + *K'Q*  

上述的方程式會誕生四種情況：  
(1) *J* = 1，*K* = 0 → *D* = *Q* + *Q'* = 1，下一個時脈邊緣觸發將會輸出設置為1  
(2) *J* = 0，*K* = 1 → *D* = 0，下一個時脈邊緣觸發將會輸出重置為0  
(3) *J* = 1，*K* = 1 → *D* = *Q'* ，下一個時脈邊緣觸發將會輸出補數  
(4) *J* = 0，*K* = 0 → *D* = *Q* ，保留原輸出不改變  

*JK* 正反器的方塊圖可以參考上方右圖，除了輸入端改成*J*與*K*，其餘皆與閂鎖器相似  


*T* (恆變)型正反器是一種互補式的正反器，如下圖(a)所示：  
![File Crash!](https://i.imgur.com/4BIMlfB.jpg)  

說穿了，就是將*JK* 正反器的兩個輸入連接在一起就能形成*T* 型正反器  
當*T* = 0(*J* = *K* = 0)時，時脈邊緣觸發無法改變輸出狀態  
當*T* = 1(*J* = *K* = 1)時，時脈邊緣觸發將輸出補數  

這種互補式正反器對於設計二進位計數器相當有用  

*T* 型正反器可由一組*D* 型正反器和一個XOR閘組成，如上圖(b)所示，並可以將*D*表示為：  
*D* = *T*⊕*Q* = *TQ'* + *T'Q*  

*T* 型正反器的方塊圖會在輸入處改為 *T*，其餘則與閂鎖器相似  

---
特性表定義一個正反器的邏輯性質，並藉由表格的形式去描述其動作  
三種不同型式的正反器特性表如下：  
  
![File Crash!](https://i.imgur.com/zSiBtoW.jpg)  

*Q*( *t* )為目前狀態；*Q*( *t* +1)則是次一狀態，出現在一個時脈週期之後  
注意：時脈邊緣觸發並未包含在特性表內，但是意味著發生在時間 *t* 和 *t* +1之間  

因此*Q*( *t* )為時脈邊緣觸發之前一瞬間的正反器狀態；  
*Q*( *t* +1)則代表因時脈轉變所造成的狀態  

至於三種正反器的特性表說明，可以搭配前幾段介紹一起對照  

---
正反器的邏輯性質可以用特性表來表示，也可以用特性方程式去描述，例如：  
對*D* 型正反器而言，特性方程式為 ─ *Q*( *t* +1) = *D*  
此式說明了輸出的次一狀態等於目前狀態的輸入值*D*  

對*JK* 正反器而言，特性方程式為 ─ *Q*( *t* +1) = *JQ'* + *K'Q*
此式的*Q* 是正反器在加入一時脈邊緣之前的輸出  

對*T* 型正反器而言，特性方程式為 ─ *Q*( *t* +1) = *T*⊕*Q* = *TQ'* + *T'Q*  

---
部分正反器本身擁有非同步輸入，可用來強制正反器變成特殊的狀態，且與時脈無關  
能夠將正反器設置為1的輸入，稱為**預先設置(preset)**或**直接設置(direct set)**  
能夠將正反器設置為0的輸入，稱為**清除(clear)**或**直接重置(direct reset)**  

下面是一個具有有效─低準位非同步重置功能的正緣觸發*D* 型正反器：  
![File Crash!](https://i.imgur.com/kxB3iU0.jpg)  


除了增加一個重置輸入連接到三個閂鎖器NAND閘以外，整體與前面的*D* 型正緣觸發正反器相同  
當重置輸入為0時，將強制使輸出*Q'* 停留在1，同時清除*Q* 為0，**效果相當於重置整個正反器**  

從重置輸入接出的另外兩條連接線，可以確保當重置輸入為0時，第三個(右邊的)*SR* 閂鎖器的*S* 輸入會停留在邏輯1，無論*Clk* 與*D* 為何  


具有直接重置輸入的*D* 型正反器，其圖示符號具有用*R* 標示的額外輸入  
輸入端的圓泡表示正反器在邏輯0準位執行重置  

具有直接設置輸入的正反器，其圖示符號具有用*S* 標示的額外輸入  



<h2 id = "4"> 4. 時控序向電路分析 </h2>

* 一個時控序向電路的動作取決於其輸入、輸出以及其正反器的狀態
* 而其輸出與次一狀態又是輸入及目前狀態的函數

---
分析一個序向電路必須使用包含輸入、輸出及內部狀態的時序圖或時序表  

時控序向電路的動作可利用狀態方程式而以代數描述  
**狀態方程式(state equation)**，也可稱為**轉移方程式(transition equation)**，說明著次一狀態是輸入及目前狀態的函數  

現在考慮下面這個電路圖：  
![File Crash!](https://i.imgur.com/vOkGgpD.jpg)  

我們會在接下來的講解中正明它是一個0─偵測器，即藉由確認其輸出在一串的1中何時會偵測到一個0  
這個電路具有兩個*D* 型正反器*A* 與*B* 、輸入變數*x* ，輸出變數*y*  
由於正反器的輸入*D* 可以決定次一狀態值，因此電路的狀態方程式可以寫成如下：  
*A*(*t* + 1) = *A*(*t*)*x*(*t*) + *B*(*t*)*x*(*t*)  
*B*(*t* + 1) = *A'*(*t*)*x*(*t*)  

**狀態方程式是用來說明正反器狀態轉變情形的代數表示式**  
左邊的(*t* + 1)是指次一狀態，右邊的函式自然會以目前狀態為變數去撰寫，因此還能簡寫如下：  
*A*(*t* + 1) = *Ax* + *Bx*  
*B*(*t* + 1) = *A'x*  

因為組合電路的*D* 值決定次一狀態，所以狀態方程式之布林表示式可直接由構成序向電路的組合電路部分之邏輯閘推導而得  
而最後輸出目前狀態值可以寫為：  
*y*(*t*) =[*A*(*t*) + *B*(*t*)]*x'*(*t*)  

最後移除表示目前狀態的(*t*)，就可以得到輸出之布林表示式：  
*y* =(*A* + *B*)*x'*  

---
輸入、輸出即正反器的時序，可以用**狀態表(state table)**(或稱**轉變表(transition table)**)去表示  

針對上面的電路，我們可以完成下面的狀態表：  
![File Crash!](https://i.imgur.com/VPmSa0f.jpg)  

目前狀態 ─ 任何已知時間*t*之情況下，正反器*A* 與*B* 的狀態  
輸入 ─ 對每一個可能的目前狀態的*x* 值  
次一狀態 ─ 正反器在一個時脈週期之後於*t* +1時的狀態  
輸出 ─ 時間*t* 之目前狀態即輸入情況下，輸出之*y*值  

**一個狀態表的推導，需要明列所有目前狀態和輸入可能產生的二元組合**，以上圖為例，則有著八種二元組合  
當然，我們也可以藉由狀態表去推導出*A*與*B*的狀態方程式，答案自然是同樣的，讀者不妨試試看：  
*A*(*t* + 1) = *Ax* + *Bx*  
*B*(*t* + 1) = *A'x*  
*y* =(*A* + *B*)*x'*  

一個具有*D* 型正反器之序向電路的狀態表，可以依照前面所提範例的相同程序去獲得  
一般來說，具有*m* 個正反器和 *n*個輸入的序向電路，狀態表需要2<sup>*m*+*n* </sup>列  
從0到2<sup>*m*+*n*</sup> -1的二進位數字則列於目前狀態與輸入行之下  
次一狀態有 *m*行，每行表示每一個正反器的次一狀態，次一狀態的二進位值可以直接從狀態方程式獲得  

輸出部分的行數則與輸出變數的數量相同，其二進位值可由電路，或是真值表中的布林函數獲得  

此外，也有人選擇用下面的形式呈現狀態表，結論是一樣的，全憑讀者喜好：  
![File Crash!](https://i.imgur.com/fyCnwHz.jpg)  

---
另外，在狀態表裡呈現的資料，也可以用圖解的方式呈現，稱為**狀態圖**  

在狀態圖中，狀態以圓圈呈現，狀態間的轉換則以連接兩圓圈的射線(箭頭)表示  
持續第一個電路圖的範例所完成的狀態圖如下：  
![File Crash!](https://i.imgur.com/sJ5sjs4.jpg)  

上面的狀態圖所提供的資訊與前面的狀態表相同，圓圈內的二進位數字代表正反器的狀態  
兩狀態之間的射線(箭頭)有兩個數字被斜線隔開，左邊是輸入(*x*)；右邊是輸出(*y*)  

**需要注意的是，沿著箭頭紀載輸出的位元值，發生於目前狀態和已知的輸入期間，並且無法影響次一狀態的轉變**  
舉例來說，從狀態00到01的箭頭，標示著1/0，表示此電路的目前狀態如果是00，則在輸入*x* = 1時，輸出為0，且在下一次時脈觸發以後，電路次一狀態將轉變為01  

接著如果輸入改為0，則輸出變成1並且次一狀態會回到00；反之輸入維持在1，則輸出為0，且次一狀態將前進到11  

<pre>
狀態圖利用圖形表示狀態轉換，較為人所接納，也更是和描繪電路的動作(較直觀)
而且前面提到，我們會證明這是一個0─偵測器的電路  
現在看看狀態圖，可以發現當輸入為0時，輸出都會回到起始狀態00，作用正是偵測資料位元串中的零
</pre>

---
一個序向電路的邏輯圖由正反器和邏輯閘所組成  
正反器的形式和組合電路的布林表示式將會提供繪製序向電路邏輯圖所需的資訊  

產生外部輸出之組合電路的部分，可用一組稱為**輸出方程式(output equations)**的布林函數而以代數方式描述  
正反器輸入的電路部分，則使用一組稱為**輸入方程式(input equations)**(或稱**激勵方程式(excitation equations)**)的布林函數而以代數方式描述  

下面讓我們依照慣例採用正反器的輸入符號來代表輸入方程式的變數，下標來表示該正反器的輸出名稱，例如：  
*D<sub>Q</sub>* = *x* + *y*  
上述方程式的解讀為 ─ 輸入*x* 與*y* 的OR閘作為正反器的輸入*D* ，而該正反器的輸出命名為*Q*  

正反器輸入方程式構成一個便利的代數形式，可以用來說明序向電路的邏輯圖  
這裡需要注意，一個*D* 型正反器的輸入方程式之數學表示式與其所對應的狀態方程式之數學表示式相同  
這是因為次一狀態的 **特性方程式(characteristic equation)** 與輸入 *D* 相同：*Q*(*t* +1) = *D<sub>Q</sub>*  

---
現在用一個簡單的例子，來分析一個具有*D* 型正反器的時控序向電路  
要分析的電路是 ─ *D<sub>A</sub>* = *A* ⊕ *x* ⊕ *y*

*D<sub>A</sub>*表示一個輸出為*A* 的*D* 型正反器，*x*與*y*為輸入
**注意：這裡未給定輸出方程式，也就是說輸出是由正反器的輸出而來**  


由輸入方程式繪製的電路圖如下：  
![File Crash!](https://i.imgur.com/0kCiqrX.jpg)   

當然也可以順勢完成狀態表，這個電路有一個正反器*A* 的目前狀態以及兩個外部輸入，因此會有八個二進數組合，務必一一列出  
接著可以從狀態方程式得知次一狀態為： *A*(*t* +1) = *A* ⊕ *x* ⊕ *y*

那麼這個電路有一個正反器與兩個狀態，分別是0和1，因此會有兩個表示狀態的圓圈  

至於箭頭上的數字表示方法為何與之前的不同？是因為這次的電路中沒有輸出  
**※注意，這裡的「沒有輸出」是指沒有連接到組合電路的輸出，而這次只有會拿去做回授路徑的正反器輸出A**

最後，在每一個狀態轉換期間都有兩種輸入組合，為簡化記號才把相同的結果合併成一個箭頭再用逗號隔開(否則原本應有八個箭頭)

---
解說完*D* 型正反器以後，輪到*JK* 正反器  
一個*JK* 或*T* 型正反器的序向電路，次一狀態可以從下面的程序中獲得：  
1. 用目前狀態和輸入變數去表示，決定正反器的輸入方程式  
2. 列出每一個輸入的方程式的二進位值  
3. 使用相對應的正反器特性表，決定狀態表中的次一狀態值  

現在考慮下面的序向電路圖：  
![File Crash!](https://i.imgur.com/0zuKZL3.jpg)  

這個電路包含兩個*JK* 正反器(*A*與*B*)，以及一個輸入*x* ，順帶一提，這個電路沒有輸出，所以在之後的狀態表可以省略  
**(當然，也可以將*AB*兩正反器的輸出當成整個電路的輸出)**  

接著觀察電路圖來完成兩個正反器的輸入形式：  
*J<sub>A</sub>* = *B* ； *K<sub>A</sub>* = *Bx'*  
*J<sub>B</sub>* = *x'* ； *K<sub>B</sub>* = *A'x* + *Ax'* = *A* ⊕ *x*  

這個序向電路的狀態表如下所示：  
![File Crash!](https://i.imgur.com/TBwXZ4b.jpg)  

目前狀態和輸入列總共有八種位元組合  
**注意：最右邊的正反器輸入共有四列，他們不屬於狀態表的一部份，卻是計算次一狀態所必要的資訊**  

正反器輸入的四列之值可以由上面的四個輸入方程式獲得，有四種情況要考慮：  
*J* = 1且*K* = 0時，次一狀態為1  
*J* = 0且*K* = 1時，次一狀態為0  
*J* = *K* = 0時，次一狀態不改變
*J* = *K* = 1時，次一狀態為目前狀態的補數  

舉例來說，當目前*AB* = 10且輸入*x* =0，則透過輸入方程式可以得到以下資訊：  
*J<sub>A</sub>* = 0 ；*K<sub>A</sub>* = 0  
*J<sub>B</sub>* = 1 ； *K<sub>B</sub>* = 1  

在根據上面的四種情況可以得到次一狀態的  
*A* = 1(第三種情況：*J* = *K* = 0時，次一狀態不改變)    
*B* = 1(*J* = *K* = 1時，次一狀態為目前狀態的補數)  

次一狀態值也可借由計算特性方程式中的狀態方程式而得，步驟如下：  
1. 以目前狀態和輸入變數來表示，決定正反器的輸入方程式  
2. 將輸入方程式帶入正反器的特性方程式已獲得狀態方程式  
3. 使用相對應的狀態方程式以決定狀態表中的次一狀態值  

以上面的電路圖為例，兩個*JK* 正反器的輸入方程式可以寫成下面兩式：  
*A*(*t*+1) = *JA'* + *K'A*  
*B*(*t*+1) = *JB'* + *K'B*  

接著將輸入方程式中的*J<sub>A</sub>* 、*K<sub>A</sub>* 等四個值代入，可以得到：  
*A*(*t*+1) = *BA'* + (*Bx'*)*'A* = *A'B* + *AB'* + *Ax*  
*B*(*t*+1) = *x'B'* + (*A* ⊕ *x*)*'B* = *B'x'* + *ABx* + *A'Bx'*  

注意，如果是使用上面兩式，那麼先前的狀態表中就不需要正反器輸入的部分了

繪製成狀態圖如下，同樣地，因為沒有輸出，所以就不需要特地用斜線隔開了：  
![File Crash!](https://i.imgur.com/MX5FiDJ.jpg)  

---
*T* 型正反器的次一狀態獲得步驟與*JK* 正反器相同，前面關於*T* 型正反器的特性表已經提到：  
*Q*(*t*+1) = *T* ⊕ *Q* = *T'Q* + *TQ'*  


現在考慮下面的序向電路圖：  
![File Crash!](https://i.imgur.com/sr0e347.jpg)  

這個電路包含兩個*T* 型正反器(*A*與*B*)、一個輸入*x*，以及一個輸出*y*  
並可透過兩個輸入方程式和一個輸出方程式做代數描述：  
*T<sub>A</sub>* = *Bx*  
*T<sub>B</sub>* = *x*
*y* = *AB*  

電路的狀態表如下：  
![File Crash!](https://i.imgur.com/C1GsdpF.jpg)  

狀態表中的*A,B*次一狀態同樣可以透過狀態方程式計算而得  
至於狀態圖也可以在上面圖中找到，由於這次有了輸出*y* ，因此圓圈內需要用斜線隔開，左邊是目前狀態的*A,B*值；右邊是輸出*y*  

---
一個序向電路最通用的模型包含輸入、輸出與內部狀態，習慣上分成兩種：  
**密利模型(Mealy model)**與**莫爾模型(Moore model)**

兩種模型的基本概念圖如下方所示：  
![File Crash!](https://i.imgur.com/FNv0w4B.jpg)  

最大的差別在於 ─ **輸出值產生的方式不同**  

密利模型裡，輸出的是目前狀態和兩個輸入的函數  
莫爾模型則只有輸出目前狀態  

這兩種序向電路通常被歸類為**有限狀態機(finite state machine，FSM)**  
屬於密利模型的序向電路就會被稱為密利機或是密利FSM，例如本節的0─偵測電路(第一個電路圖)；  
同理，屬於莫爾模型的序向電路就會被稱為莫爾機或是莫爾FSM，例如本節的*JK* 正反器分析範例  


在莫爾模型中，**序向電路的輸出會與時脈同步，是因為正反器的輸出與時脈同步，而序向電路的輸出僅依正反器的輸出而定所導致**  
而在密利模型中，時脈週期內，若輸入改變則輸出可能改變，除此之外，輸出也有可能產生「瞬間」的錯誤值，是因為會遇到輸入改變時的時間延遲和造成輸出改變的時間延遲有所不同的困難  

因此，如果要讓密利機達成同步，序向電路的輸入就必須與時脈同步，並且輸出只能夠於時脈邊緣的前一瞬間被取樣  
輸入會在時脈的無效邊緣被改變，以確保正反器的輸入在時脈有效邊緣發生之前呈現穩定  
結論是，**密利機的輸出就是時脈有效邊緣觸發之前的瞬間值**


<h2 id = "5"> 5. 狀態簡化與指定 </h2>

* 序向電路的分析可從電路圖著手，直到完成狀態表或狀態圖為止
* 本節將討論正反器的特性，以達到簡化邏輯閘數目及其所使用的正反器數目

---
序向電路中正反器數目的簡化被歸類為 **狀態簡化(state-reduction)** 問題  
狀態簡化演算法主要強調 ─ **保持外部輸入-輸出條件不變下，如何簡化狀態表中的狀態數目**  

因為*m* 個正反器會產生2 *<sup>m</sup>* 個狀態，狀態數目的簡化**「可能」**會造成正反器數目的簡化  
但是，簡化正反器的數目偶爾會需要更多的組合邏輯閘去實現次一狀態與輸出邏輯  

現在考慮一個序向電路，狀態圖如下：  
![File Crash!](https://i.imgur.com/3bpwREi.jpg)  

這個範例著重在輸入-輸出的順序，內部狀態僅以英文字母取代二進位數字  
對於一個電路，輸入可以有無限多種輸入順序，每一種輸入順序也都會產生相對應且獨特的輸出順序  

舉例來說，以*a* 為初始狀態下輸入01010110100，則我們可以根據狀態圖得到下面的順序：  
![File Crash!](https://i.imgur.com/Oxz91d4.jpg)  

每一行都包含了輸入、輸出以及目前狀態，而次一狀態即是隔一行的最上方之字母  


那麼現在，假設我們找到另外一個電路，狀態圖的狀態少於七個，而且如果把上面的順序加入至兩個電路中可以得到相同的輸出  
那麼我們可以稱為兩個電路是**等效的**  

換言之，所謂的狀態簡化，就是**在不影響輸入-輸出的關係下，如何減少序向電路的狀態數目的方法**  

那麼我們先嘗試減少這個範例的狀態數目，從觀察狀態圖可以完成狀態表如下：  
![File Crash!](https://i.imgur.com/hDCrf5Z.jpg)  

一個完整指定的狀態表的狀態簡化法，可以不需證明地描述成如下的演算法：  
「對每一組輸入的成員而言，他們可以得到完全相同的輸出，並且使電路達到相同或相等的狀態時，此兩狀態為等效」  
也就是說，如果兩狀態等效，那麼刪除其中一個狀態也不會影響原有的輸入-輸出關係  

把上述的觀念套用進狀態表中，可以發現*e* 與*g* 就是等效狀態，在*x* 輸入0與1，次一狀態都是*a* 與*f* ，且輸出均為0與1  
顯然地，*g* 是可以除去的，至於狀態表中其他關於*g* 的欄位就用*e* 取代，可以得到第一次簡化的狀態表如下：  
![File Crash!](https://i.imgur.com/scXAkCs.jpg)  

上面提到第一次簡化，是為什麼呢？很簡單，因為還能繼續簡化！  

在*e* 取代 *g* 的位置以後，我們可以發現*d* 與 *f* 也是等效  
同樣地，將*f* 從狀態表中刪除，並用*d* 來取代其他*f* 的項目，可以得到第二次簡化的結果：  
![File Crash!](https://i.imgur.com/0RuvzEW.jpg)  

這次再也沒有相同輸入-輸出關係的狀態，因此達到了最終簡化的結果，繪製成狀態圖如下：  
![File Crash!](https://i.imgur.com/ey254gm.jpg)  

此狀態圖不僅滿足原屬的輸入-輸出規格，同時對於已知的任何輸入順序，都能產生所需的輸出順序，完整如下：  
![File Crash!](https://i.imgur.com/b4xPr6a.jpg)  

注意：簡化是指輸出順序不變，目前狀態少了*f* 與*g* 才是正常的  

但是，被簡化為較少狀態的狀態表，卻不能保證一定可以減少正反器或邏輯閘的數量  

---
**為了用實際的元件設計一個序向電路，將一個獨特已編碼的二進位值指定給狀態是必須的**  

一個具有*m* 狀態的電路，此二進位碼必須包含*n* 個位元，其中2 *<sup>n</sup>* ≥ *m*  

如果應用到前面的範例，因為有五個狀態(未經簡化時為七個)，所以二進位碼需要3個位元(2<sup>3</sup> ≥ 5與7 ≥ 2<sup>2</sup>)  
二進位碼數自從000到111  

下面以簡化後的五個狀態為例，此時會**有三個狀態未被使用，因此當作不理會條件**  
通常不理會條件有助於簡化電路(參閱前面章節)，但依舊老話一句，這不能保證能夠使用較少的邏輯閘  

五個狀態的最簡單編碼方式，就是使用二進位計數順序的前五個整數，如下面狀態表的第一種指定方式  
另一種類似的指定是使用葛雷碼，如下面狀態表的第二種指定方式  
![File Crash!](https://i.imgur.com/9lXDN4T.jpg)  

這兩種方式都是從一個數到另一個數時，僅有一個位元改變，使布林函數的簡化更加容易  

第三種則是經常用於狀態機至控制資料路徑單元設計之可能的指定是one-hot指定  
型態是使用和電路中的狀態一樣多的位元數量，在任何已知的時間裡，只有一個位元值為1(其餘為0)  
**one-hot編碼通常可以得到較簡單的次一狀態與輸出解碼邏輯，有興趣的讀者可以自行查閱資料**  


使用第一種二進位指定曲代字母之簡化狀態表如下：  
![File Crash!](https://i.imgur.com/xRRTjLc.jpg)  

對於每個狀態而言，不同種類的指定將會產生不同二進位值的狀態表  
狀態表的二進位形式，被用來推導出序向電路的次一狀態與輸出所形成之組和電路部分  
所以，組合電路的複雜度將會根據二進位狀態指定形式而定  

有時候，我們會將第一種二進位指定的狀態表稱作**轉變表(transition table)**  
因為在使用上，以及用符號代表狀態表中的狀態有所區別


<h2 id = "6"> 6. 設計程序 </h2>

* 合成工具所使用的序向建構方塊為*D* 型正反器
* 結合其他的邏輯，*D* 型正反器也可執行*JK* 與*T* 型正反器

---
一個時控序向電路的設計須從其規格著手，進而獲得其邏輯圖  
或是先得出一列布林函數，再由此求得邏輯圖  

與一個可以用真值表完整描述的組合電路兩相比較，序向電路則需要一個狀態表作為其規格  
序向電路的第一個步驟，**就是去獲得狀態表或等效的表示方式(狀態圖)**  


同步序向電路是由正反器急組合邏輯閘所構成  
電路的設計包括選擇正反器及尋找組合邏輯閘，並且將兩者結合建構成一個可實現所指定規格的電路  

從電路的**狀態數**去決定**正反器的數量**，組合電路則經由計算正反器輸入及輸出方程式而由狀態表獲得  
一旦正反器的形式和數量已經決定，設計程序就成為從序向電路至組合電路的轉換問題  

設計序向電路的程序可以整理成下面幾個建議步驟：  
1. 從文字敘述及所需要的操作規格，推導出電路的狀態圖  
2. 如有需要，簡化狀態數量  
3. 指定狀態的二進位值  
4. 求出二進位編碼的狀態表  
5. 選擇欲使用的正反器形式  
6. 推導出已簡化的輸入方程式及輸出方程式  
7. 繪製邏輯圖  


萬事起頭難，最具成功關鍵性的當屬步驟1，以下透過例子配合說明：  
假設現在我們要設計一個電路，能夠偵測出在輸入端的一串位元中(亦即，輸入是一個**串列式位元串(serial bit stream)**),有三個或更多連續的1出現，此電路的狀態圖如下：  
![File Crash!](https://i.imgur.com/UGMj1cW.jpg)  

初始狀態為*S*<sub>0</sub>，只要輸入為1就會依序進入*S*<sub>1</sub> 至 *S*<sub>3</sub>，當狀態在 *S*<sub>3</sub> 且繼續偵測到1時則持續停留在 *S*<sub>3</sub>  

途中只要偵測到0就會回到初使狀態*S*<sub>0</sub> ，倘若於*S*<sub>0</sub> 收到輸入0則持續停留在 *S*<sub>0</sub>  
※這也是一個莫爾模型序向電路，因為其*S*<sub>3</sub>狀態時輸出為1，其餘皆為0  

---
有了狀態圖以後，其餘設計的部分則可以依據明確的合成程序  
這裡我們必須指定這些狀態的二進位碼並列出狀態表，如下圖所示：  

![File Crash!](https://i.imgur.com/FNVS2RI.jpg)  
我們先用兩個*D* 型正反器去代表四個狀態，輸出分別為*A* 與*B*  ，有一個輸入*x* 與輸出*y*  
*D* 型正反器的特性方程式為*Q*(*t* +1) = *D<sub>Q</sub>*  

這表示狀態表的次一狀態值指定了正反器的*D* 輸入條件  
正反器的輸入方程式可直接由*A* 與*B* 的次一狀態行獲得，並可表示成全及項的和為：  
*A*(*t* +1) = *D<sub>A</sub>*(*A*,*B*,*x*) = Σ(3,5,7)    
*B*(*t* +1) = *D<sub>B</sub>*(*A*,*B*,*x*) = Σ(1,5,7)  
*y*(*A*,*B*,*x*) = Σ(6,7)  

其中*A* 與 *B* 代表正反器*A* 和正反器*B* 的目前狀態值，*x* 是輸入，*D<sub>A</sub>* 和 *D<sub>B</sub>* 則是輸入方程式  
輸出*y* 的全及項可以從狀態表的輸出行來獲得  


布林方程式的部分則可以透過繪製卡諾圖去簡化，卡諾圖如下：  
![File Crash!](https://i.imgur.com/HVhIBZJ.jpg)  

簡化後的方程式為：  
*D<sub>A</sub>* = *Ax* + *Bx*  
*D<sub>B</sub>* = *Ax* + *B'x*  
*y* = *AB*  

利用*D* 型正反器設計的優點是，描述正反器輸入的布林方程式可以直接由狀態表求得  
而這個序向電路的邏輯圖如下所示：  
![File Crash!](https://i.imgur.com/saAK59b.jpg)  

---
對於序向電路的設計，如果使用*D* 型正反器以外的形式都會有些複雜  
其原因是 **電路的輸入方程式須從狀態表間接獲得** ，例如*JK* 與*T* 型正反器  

為了決定這些正反器的輸入方程式，必須在狀態表和輸入方程式之間推導出一個函數關係  

在設計程序中，我們通常知道從目前狀態到次一狀態的轉變，並且希望能找到造成如此轉變的正反器輸入條件  
有鑑於此，對一已知的狀態改變，我們需要用一個表來列出必要的輸入條件，稱為**激勵表(excitation table)**  

下面為兩種正反器的激勵表：  
![File Crash!](https://i.imgur.com/RiEfN51.jpg)  

每個表都有目前狀態、次一狀態以及每個輸入以顯示所需要的轉變如何達成  
從目前狀態到次一狀態有四種可能的改變，改變的輸入條件可以借由特性表提供的資訊裡得到，X即為不理會條件  

上圖的(a)是*JK* 正反器  
當目前狀態與次一狀態皆為0時，*J* 必須停留在0，*K* 則無所謂(可0或1，因此當作不理會條件)；  
同理，當目前狀態與次一狀態皆為1時，*K* 必須停留在0，*J* 則無所謂(可0或1，因此當作不理會條件)  

若正反器產生一個從狀態0到狀態1的轉變，*J*必須為1，因為輸入*J* 以設置該正反器  
注意，此時若*K* =0，則*J* =1為設置該正反器的條件；若*K* = 1，則正反器發生變補現象(即由狀態0變為狀態1)  
因此，狀態由0轉為1時，*K* 被標示為不理會條件  

再者，若正反器從狀態1轉變為狀態0，*K*必須為1，因為輸入*K* 以重置該正反器  
同樣地，*J* 被視為不理會條件，*J* =0時沒有效用；*J* =1時產生變補現象(即由狀態1變為狀態0)  

*T* 型正反器如上圖(b)所示，當輸入*T* =1時，正反器的狀態取補數；*T* =0時，正反器狀態維持不變  
因此，當正反器的狀態維持相同時，其條件為*T* =0；正反器的狀態需要轉變時，*T* =1  

---
現在我們練習使用*JK* 正反器之合成方法，先給定下面的狀態表：  
![File Crash!](https://i.imgur.com/Nt1GTWd.jpg)  

除了基本項目以外，也顯示正反器的輸入條件，借由這些條件可以推得輸入方程式  
對於*JK* 正反器來說，其輸入可藉由狀態表結合激勵表來獲得(即參考上一部分的正反器激勵表去完成上圖正反器輸入等四欄)  

上表的正反器輸入部分，說明了輸入方程式的真值表為目前狀態*A* 與*B* 及輸入*x* 的函數
至於正反器輸入則可以用卡諾圖加以簡化，四份卡諾圖以及輸入方程式如下：  
![File Crash!](https://i.imgur.com/QgxpDw0.jpg)  

簡化過程中不會使用到次一狀態，僅由目前狀態與輸入作為二進位碼進行繪製  

使用*JK* 正反器的優點在於 **擁有大量的不理會條件** ，可以有效化簡組合電路的表示式  
(但是實際上還是*D* 型正反器更適合用於自動化設計流程)  

最後完成的序向電路圖則如下圖所示：  
![File Crash!](https://i.imgur.com/9lBsseX.jpg)  

---
最後讓我們練習使用*T* 型正反器之合成方法─透過設計一個二進位計數器為例  

一個*n* 位元的二進位計數器是由*n* 個正反器組成，計數範圍是0 ~ 2 *<sup>n</sup>* -1  
一個三位元的二進位計數器的狀態圖如下所示：  
![File Crash!](https://i.imgur.com/u3wDXIg.jpg)  

狀態圖中只是單純的執行+1的計數動作，其中111之後會回到000，每個箭頭之間沒有標示輸入與輸出值  
注意：時控序向電路僅在時脈邊緣期間發生狀態轉變，若沒有時脈配合，正反器將維持在其當下之目前狀態  

因為這個原因，時脈不像狀態圖或狀態表中的輸入變數一般清楚地出現  
電路的唯一輸入是時脈，而輸出則由正反器的目前狀態指定  
計數器的次一狀態完全根據目前狀態而定，並且每次時脈通過一個轉變時，狀態也會轉變  

下圖為這個三位元的二進位計數器的狀態表：  
![File Crash!](https://i.imgur.com/uLipdHd.jpg)  

三個正反器分別標示為*A*<sub>2</sub>,*A*<sub>1</sub>,*A*<sub>0</sub>  
使用*T* 型正反器來建構二進位計數器是最有效率的，因為它具有互補性質  

*T* 型正反器的輸入可以從檢視*T* 型正反器的激勵表及目前狀態至次一狀態的轉變中獲得  

舉例來說，假如正反器位於001的那一列輸入，001即為正反器之目前狀態，次一狀態為010  
然後比較這兩數，可以得知*A*<sub>2</sub>從0變成0，所以*T<sub>A2</sub>* 被標記為0  
因為時脈來時，正反器*A*<sub>2</sub>保持不變  

而*T<sub>A1</sub>* 與*T<sub>A0</sub>* 將會被標示為1，因為時脈來時，正反器*A*<sub>1</sub> 與*A*<sub>0</sub>狀態轉變  

這些正反器之輸入方程式也同樣可以藉由卡諾圖加以簡化，下方為其簡化過後的輸入方程式：  
![File Crash!](https://i.imgur.com/UTH3X3p.jpg)  

注意：*T<sub>A0</sub>* 的八個項全是1，因為對於計數器來說，最低位元在每一次計數中都必須變補  

繪製後的邏輯電路圖如下：  
![File Crash!](https://i.imgur.com/NjUd1fP.jpg)  

此電路結合了三個正反器的輸入方程式而繪製而成  
注意：這個電路是為了簡潔才沒有顯示重置信號，現實中的每一項電路設計都必須包含有重置信號


<h2 id = "A2"> A2. 單字對證 </h2>

* 序向電路 ─ sequential circuits
* 目前狀態 ─ present-state
* 次一狀態 ─ next-state
* 設置狀態 ─ set-state
* 重置狀態 ─ reset-state
* 未定義的次一狀態 ─ undefined next state
* 同步序向電路 ─ synchronous sequential circuit
* 非同步序向電路 ─ asynchronous sequential circuit
* 延時 ─ time-delay
* 時脈脈波 ─ clock pulses
* 時脈產生器 ─ clock generator
* 時脈序向電路 ─ clock sequential circuits
* 同步電路 ─ synchronous circuits
* 正反器 ─ flip-flop
* 閂鎖器 ─ latches
* 輸出 ─ outputs
* 函數表 ─ function table
* 透明的閂鎖器 ─ transparent latch
* 準位 ─ level
* 正準位響應 ─ positive level response
* 轉變 ─ transition
* 正緣 ─ positive-edge
* 負緣 ─ negative-edge
* 主閂鎖器 ─ master latch
* 僕閂鎖器 ─ slave latch
* 正轉變 ─ positive-transition
* 反應時序 ─ timing of the response
* 設定時間 ─ setup time
* 保持時間 ─ hold time
* 傳播延遲時間 ─ propagation delay time
* 時間間隔 ─ time interval
* 動態標誌 ─ dynamic indicator
* 狀態方程式 ─ state equation
* 轉移方程式 ─ transition equation
* 輸出方程式 ─ output equations
* 輸入方程式 ─ input equations
* 激勵方程式 ─ excitation equations
* 特性方程式 ─ characteristic equation
* 密利模型 ─ Mealy model
* 莫爾模型 ─ Moore model
* 有限狀態機 ─ finite state machine，FSM
* 分析 ─ analysus
* 狀態簡化 ─ state-reduction
* 串列式位元串 ─ serial bit stream
* 激勵表 ─ excitation table
* 

<h2 id = "A3"> A3. 後記與參考 </h2>
<h4>參考書目</h4>

* 數位邏輯設計 - 滄海書局：[https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212](https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212 "數位邏輯設計 - 滄海書局")
* Digital Design: With an Introduction to the Verilog HDL：[https://www.tenlong.com.tw/products/9780273764526](https://www.tenlong.com.tw/products/9780273764526 "Digital Design: With an Introduction to the Verilog HDL")

<h4>援引資料</h4>

* 維基百科： [https://zh.wikipedia.org/wiki/ASCII](https://zh.wikipedia.org/wiki/ASCII "維基百科")
