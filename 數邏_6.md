## 本章目標
>了解暫存器與計數器之基本介紹

## 目錄
* [A1. 前言與聲明](#A1)
* [1. 暫存器](#1)
* [2. 移位暫存器](#2)
* [3. 漣波計數器](#3)
* [A2. 單字對證](#A2)
* [A3. 後記與參考](#A3)

<h2 id = "A1"> A1. 前言與聲明 </h2>
在進入數位邏輯設計的同時，也意味著你將要開始以數位世界的思維與規則在思考各種觀念與問題，
 
請整理好思緒，別讓自己前後矛盾而混淆了許多簡單的觀念。另有以下幾點聲明須知：

* 本教學歡迎轉載分享，唯獨不得做為商業利益使用，內容援引之範例，其版權皆屬原作者所有
* 講義內容之安排係以國立臺北教育大學數位科技設計學系安排之課程內容為主，若有未提及之處，請善用網路資源
* [A2. 單字對證](#A2)中對於各項專有名詞之名稱將以參考書目為準，若有疑問，請善用網路資源
* 參考書目及其他援引資訊將列於[A3. 後記與參考](#A3)


<h2 id = "1"> 1. 暫存器 </h2>

* 含有正反器的電路通常以其執行的功能來分類，而不是以序向電路的名稱來分類
* 有兩種此類電路，分別是暫存器與計數器

---
**暫存器(register)** 是一群正反器組成，每一個正反器共用一個共同的時脈，且可儲存一個位元的資料  
一個*n* 位元的暫存器是由一群*n* 個正反器所構成，可以用來儲存*n* 位元的二進位資料  

暫存器也可以同時包含組合電路已執行特定的資料處理工作  
廣義來說，一個暫存器是由一群正反器連同一些會影響它們操作的邏輯閘組合而成


**計數器(counter)** 本質上是一個暫存器，依照預定的順序轉變其二進位狀態  
計數器中的邏輯閘被加以連接，用以產生預定的狀態順序  


最簡單的暫存器如下圖所示：  
![File Crash!](https://i.imgur.com/saffLY7.jpg)  

由四個*D* 型正反器所組成，形成一個四位元暫存器  
共同的時脈輸入在正緣時觸發所有正反器，並且出現在四個輸入端的二進位資料會被轉移到這個暫存器  

在時脈邊緣觸發之前，*I<sub>0</sub>* ~*I<sub>3</sub>* 之值會立即決定在時脈邊緣觸發之後的*A<sub>0</sub>* ~*A<sub>3</sub>*  
這四個輸出可以在任意時間取樣以取得儲存在此暫存器內的二進位資訊  

輸入*Clear_b* 連接至四個正反器的有效-低準*R* (重置)輸入端，當此輸入端為0，所有正反器即被非同步重置  
在時脈動作之前，*Clear_b* 可用來將暫存器清除為0，這些 *R* 輸入端必須在正常的時脈動作之間維持在邏輯1(即未被確認)  
※注意：請依照正反器形式而定，*Clear,Clear_b,reset,reset_b* 都是被用來只是暫存器轉移成全部為0的狀態  

---
具有並列載入的暫存器是數位系統的基本建構區塊，了解它們的動作是很重要的課題  
同步數位系統具有一個主要的時脈產生器，供應連續的脈波串列  
時脈被應用至系統內的所有正反器及暫存器，主時脈扮演著類似心臟的角色，供應一個不變的「心跳」至系統的每一個部分  
一個獨立的控制信號必須用來決定哪一個特定時脈脈波對某一特定的暫存器產生影響  

新的資訊轉移至暫存器被稱為**載入(loading)** 或**更新(updating)** 此暫存器  
若在一個共同的時脈脈波之下，暫存器的所有位元同時被載入，稱之為 **並列載入(parallel load)**  
例如上圖的暫存器之輸入*Clk* 的時脈邊緣，可將四個輸入並列載入  
在此結構之下，若暫存器的內容必須維持不變，則輸入均必須保持固定或者時脈不可加入至電路  

第一種情況，驅動暫存器的資料匯流排無法作為其他溝通之用  
第二種情況，我們可藉由使用一個致能閘來控制時脈輸入信號，如此可控制時脈是否加至電路  


但是，在時脈路徑上插入邏輯閘不是個好方法，因為這意味著 ─ 需要時脈脈波才能執行邏輯動作，就會產生**傳輸延遲(propagation delays)**  

為了讓系統完全同步化，我們必須確認所有的時脈脈波都同時到達系統的任何位置，以致所有的正反器同時被觸發  
有鑑於此，建議使用*D* 輸入來控制暫存器的動作，而非控制正反器輸入*Clk* 的時脈  

下圖是一個具有一載入的四位元資料儲存暫存器：  
![File Crash!](https://i.imgur.com/R5QQnsg.jpg)  

其載入控制輸入是經由邏輯閘連接至正反器的輸入*D*  
這種暫存器的載入輸入決定每一個時脈脈波加入後的動作  
當載入輸入為1時，且於時脈下一個正緣時，四個輸入端的資料被轉移至暫存器  
當載入輸入為0時，正反器的輸出被連接至它們各自的輸入  

從輸出至輸入的回授連接是必要的，因為*D* 型正反器沒有「不改變」的狀態  
在每一個時脈邊緣，*D* 輸入決定了暫存器的次一狀態  
為了讓輸出保持不變，必須使*D* 輸入等於輸出的目前狀態  

時脈脈波不斷地加至*Clk* 輸入，載入輸入決定是否在下一個脈波接受新的資料或是讓暫存器內的資料原封不動  
從資料輸入端或暫存器輸出端的資料轉移，全部的四個位元會在一個時脈邊緣同時完成  


<h2 id = "2"> 2. 移位暫存器 </h2>

* 一個可將儲存在每一胞元的二元資料以所指定之方向移位至其相鄰胞元的暫存器稱為**移位暫存器(shift register)**
* 移位暫存器的邏輯結構是由一串連接成串接型式的正反器所組成，一個正反器的輸出連接到下一個正反器的輸入
* 所有正反器接受共同的時脈脈波，促成資料從某一級移位至下一級

---
最簡單的暫存器僅使用正反器，如下圖所示：  
![File Crash!](https://i.imgur.com/FYfWmvs.jpg)  

某一個特定正反器的輸出連接到它右側的正反器之數入*D*  
此種移位暫存器是單向的(左→右)，每一個時脈脈波會將暫存器的內容往右移動一個位元，同時無法支援左移操作  

**串列輸入(serial input)** 決定在移位期間進入最左邊正反器的值  
**串列輸出(serial output)** 決定在移位期間最右邊正反器的輸出值  

有時必須控制暫存器在特定時脈時產生移位，時脈信號可藉由閘控時脈信號而加以抑制，以避免暫存器在非特定時間產生移位動作  

---
一個數位系統一次轉移或處理一個位元的資料時，此系統的資料路徑被稱為操作於串列模式  
資料為一次轉移一個位元，從來源暫存器將資料位元移位至目標暫存器  
這與並列轉移形成對照，並列轉移則是在相同時間轉移暫存器內的全部位元資料  

資料從暫存器*A* 轉移至暫存器*B* ，可以用移位暫存器完成，如下圖所示：  
![File Crash!](https://i.imgur.com/RZcHTgD.jpg)  

暫存器*A* 的串列輸出(*SO*)被連接至暫存器*B* 的串列輸入(*SI*)  
為了防止儲存在來源暫存器的資料流失，暫存器*A* 的串列輸出連接至串列輸入，使暫存器*A* 的資料能循環  
暫存器*B* 的起始資料經由它的串列輸出處移出暫存器，除非能夠再轉移至第三個暫存器，否則資料將會流失  

移位控制輸入決定暫存器和時移位及移位多少次，這可以用一個AND閘完成  
當移位控制有效時，它允許時脈脈波通過抵達*CLK* 端  

假設上圖的每一個移位暫存器有四個位元，負責監督資料轉移的控制單元必須被設計成可致能移位暫存器的方式  
經由移位信號，在特定的時間產生四個時脈信號以便能通過完整的字組，如上面的(b)時序圖所示  

移位控制信號和時脈同步，且在時脈負緣之後，移位控制信號產生轉變  
在有效狀態之下，其後的四個時脈脈波和移位控制信號作用，所以在連接至*CLK* 輸入端之AND閘的輸出端，將產生四個時脈*T<sub>1</sub>* ~*T<sub>4</sub>*  

在每個時脈的正緣上升會造成兩個暫存器的一次移位，第四個脈波使移位控制轉變為0，使移位暫存器無法動作  

現在舉例說明，假如在移位之前，*A* 的二元資料為1011；*B* 的二元資料為0010  
從*A* 至*B* 的串列轉移包含四個步驟，如下表所示：  
![File Crash!](https://i.imgur.com/WkxZnl2.jpg)  
在第一個脈波*T<sub>1</sub>* 之後，*A* 的最右側位元被轉移至*B* 的最左側位元，同時也循環回到*A* 的最左側位元  
同時*A* 與*B* 的位元都往右移動一個位置，而*B* 的最右側位元被推出去(即資料流失)  

這樣的動作還會再三次(即*T<sub>2</sub>* ~*T<sub>4</sub>* )，第四次移位之後，移位控制信號變為0，且暫存器*A* 與*B* 的資料皆為1011  

<pre>
這個例子便能看出串列與並列操作模式的不同
並列模式裡，資訊是由暫存器所有的位元提供，且在一個時脈脈波內同時轉移所有位元
串列模式裡，暫存器有單一的串列輸入和單一的串列輸出，暫存器以相同方向移位，一次移位一個位元資料
</pre>

---
這裡我們以一串列加法器設計來示範說明串列操作模式  

將兩個要以串列方式相加的二進位數字分別儲存在兩個移位暫存器  
由最小位元對開始，經由一個全加法器電路，一次有一對位元相加，如下圖所示：  
![File Crash!](https://i.imgur.com/W3c3CQy.jpg)  

全加法器進位輸出轉移至一個*D* 型正反器，此正反器的輸出被當作下一對有效位元的進位輸入  
從全加法器的*S* 輸出的和(sum)位元被轉移至第三個移位暫存器  

在*A* 的位元被移出的同時，藉由將和移入*A* ，則僅使用一個暫存器來儲存被加數及和的位元是有可能的  
暫存器*B*  的串列輸入可用來轉移一個新的二進位數字；同時，加數的位元會在加法過程中被移出  

串列加法器的操作如下：  
起始狀態為 ─ 暫存器*A* 儲存被加數、暫存器*B* 儲存加數、進位正反器被清除為0  
*A* 與*B* 的輸出( *SO* )提供給全加法器一對有效的輸入位元*x* 與*y*  

正反器的輸出*Q* 提供進位輸入*z* ，移位控制同時致能暫存器及進位正反器  
因此，在下一個時脈脈波時，兩個暫存器都會向右移位一次，*S* 端的和位元值進入*A* 正反器的最左側，並且輸出進位至正反器*Q*  
移位控制啟動暫存器所需時脈的次數，等同於暫存器內的位元數  

對於每一個連續的時脈脈波而言，一個新的和之位元被轉移至*A* ，一個新的進位被轉移至*Q*  
因此，兩個暫存器都向右移位一次，上述過程持續至移位控制禁能為止  

因此，經由單一全加法器電路，將每一對位元與前一位元之進位相加，並將其和以一次一位元的方式轉移至暫存器*A* ，即可完成加法  

最初，暫存器*A* 及進位正反器清除為0，然後加上從*B* 而來的第一個數字  
當*B*被移位至全加法器時，第二個數字也經由串列輸入被轉移至*B* 
然後，當第三個數字以串列方式轉移至暫存器*B* 時，方才的第二個數字就會與暫存器*A* 的數字相加  
反覆執行上面的步驟，就可以累積它們的和在暫存器*A*  

<pre>
並列加法器使用具有並列載入的暫存器
串列加法器則使用移位暫存器

並列加法器裡，全加法器電路的數量等於二進位數字的位元數
串列加法器裡，僅需要一組全加法器電路及一個進位正反器

排除暫存器的話，並列加法器是一個組合電路；串列加法器則是一個序向電路  
</pre>


為了證明串列操作可使用序向電路程序來設計，這裡讓我們利用一個狀態表重新設計此串列加法器：  
![File Crash!](https://i.imgur.com/ZDrhPHt.jpg)  

首先假設有兩個移位暫存器可用來儲存即將串列相加的二進位數字  
暫存器的輸出分別為*x* 與*y*

※欲設計的序向電路不包含移位暫存器，但是他們稍後會被插入以顯示完整的電路    

序向電路有兩個輸入，分別為*x* 與*y* ，提供一對有效的位元，一個產生和位元輸出的*S* ，以及用於儲存進位的正反器*Q*  
*Q* 的目前狀態值即為進位的目前狀態值  
*Q* 的目前狀態進位值一起和輸入*x* 與*y* 相加後，在輸出*S* 產生一個和的位元  

*Q*的次一狀態等於此輸出進位  
※注意：現在除了輸入進位是*Q* 的目前狀態且輸出進位是*Q*的次一狀態之外，狀態表的輸入與全加法器真值表的輸入是相同的  

如果*Q* 是使用*D* 型正反器，則電路可以簡化成前面的串列加法器電路圖  
如果*Q* 是使用*JK* 正反器，就必須藉由查詢激勵表(參考第五章相關資訊)，以決定輸入*J* 與*K* 的值，如上面狀態表的末兩列  
這兩個正反器的輸入方程式及輸出方程式可透過卡諾圖簡化成：  
*J<sub>Q</sub>* = *xy*  
*K<sub>Q</sub>* = *x'y'* = (*x* + *y*)'  
*S* = *x*⊕*y*⊕*Q*  

此電路是由三個邏輯閘和一個*JK* 正反器所組成，電路如下圖所示：  
![File Crash!](https://i.imgur.com/kV7Z9Qq.jpg)  

上圖也納入兩個移位暫存器以顯示完整的串列加法器  
※注意：輸出*S* 不僅是*x* 與*y* 的函數，也是目前狀態*Q* 的函數  
*Q* 的次一狀態是*Q* 的目前狀態以及由移位暫存器串列輸出的*x* 與*y* 的函數  

---
若移位暫存器的正反器輸出是可存取的，則經由移位串列輸入的資訊可從正反器的輸出端並列取出  
若並列載入功能被加至移位暫存器，那麼以並列方式進入的資料，也可透過移位儲存在暫存器的資料而用串列方式取出  

某些移位暫存器可為並列轉移提供必要的輸入及輸出端點，它們可能同時具備向右及向左移位的能力  
最普及化的移位暫存器具有以下功能：  
1. 一個**清除(clear)** 控制將站存器清除為0  
2. 一個**時脈(clock)** 輸入使所有操作同步化  
3. 一個**右移(shift-right)** 控制用以啟動向右移位操作，以及與向右移位操作相關的串列**輸入及輸出(serial input and output)線**  
4. 一個**左移(shift-left)** 控制用以啟動向左移位操作，以及與向左移位操作相關的**串列輸入及輸出(serial input and output)線**  
5. 一個**並列載入(parallel-load)** 控制用以啟動並列轉移，以及有*n* 條與並列轉移相關的輸入線  
6. *n* 條的並列輸出線  
7. 在時脈持續供應下，有一個控制狀態可使暫存器內的資訊維持不變  

※其它的移位暫存器可能只有上述的部分功能，但「至少」具備一種移位操作的功能  

<pre>
僅能單方向移位的暫存器，稱為單向移位暫存器(unidirectional shift register)
具有雙向移位功能的暫存器，稱為雙向移位暫存器(bidirectional shift register)

至於具有雙向移位功能且擁有並列載入功能的暫存器，稱為通用移位暫存器(universal shift register)
</pre>

具備上面七項功能的四位元通用移位暫存器，方塊圖如下所示：  
![File Crash!](https://i.imgur.com/wfNztBB.jpg)  

詳細電路圖如下：  
![File Crash!](https://i.imgur.com/9HBR2W9.jpg)  

此電路是由四個*D* 型正反器及四個多工器所組成  
四個多工器具有兩個共用的選擇輸入*s<sub>1</sub>* 及*s<sub>0</sub>*  
當*s<sub>1</sub>s<sub>0</sub>* = 00時，則選擇每個多工器的輸入0；  
當*s<sub>1</sub>s<sub>0</sub>* = 01時，則選擇每個多工器的輸入1  
(其餘兩種輸入類推)  

功能表參考如下：  
![File Crash!](https://i.imgur.com/1TP3pJC.jpg)  

當*s<sub>1</sub>s<sub>0</sub>* = 00時，暫存器的現值加至正反器的*D* 輸入，這種情況形成每一個正反器的輸出連接至相同正反器輸入的一條路徑，使得其輸出能以此種操作模式循環進入輸入  

在下一個時脈邊緣時，轉移至每一個正反器的二進位值即為其先前的值，因此狀態不會改變  

當*s<sub>1</sub>s<sub>0</sub>* = 01時，多工器的輸入端點1具有一條接至正反器的*D* 輸入路徑，會造成向右移位的動作，而以串列輸入方式轉移至正反器*A<sub>3</sub>*  

當*s<sub>1</sub>s<sub>0</sub>* = 10時，會使另一個串列輸入轉移至正反器*A<sub>0</sub>*  
當*s<sub>1</sub>s<sub>0</sub>* = 11時，並列輸入線上的二進位資訊，在下一個時脈邊緣時，同時轉移至暫存器  
※注意：資料進入*MSB_in* 是執行右移操作；*LSB_in* 是左移操作  
*Clear_b* 是一個有效-低準位信號，可以清除全部的正反器  

移位暫存器通常用來作為相距遙遠之數位系統間的介面，例如：  
距離遙遠的兩點要傳輸*n* 位元的資訊，以*n* 條傳輸線來並列傳輸是相當昂貴的  
所以更加經濟的方式為 ─ 利用單線方式串列傳輸資訊，一次一個位元  

**發射器(transmitter)** 接受*n* 位元資料，以並列方式進入移位暫存器，然後沿著共通線以串列方式傳輸資料  
**接收器(receiver)** 接受資料，以串列方式進入移位暫存器  

當全部的*n* 位元資料接收後，它們可用並列方式從暫存器的輸出獲取  
因此，發射器執行一種**並列至串列(parallel-to-serial)** 的轉換；
而接收器則進行一種資料的**串列至並列(serial-to-parallel)** 的轉換  


<h2 id = "3"> 3. 漣波計數器 </h2>

* 暫存器根據輸入時脈，經歷規定的狀態順序，稱為**計數器(counter)**
* 依照二進位數字順序的計數器，稱為**二進位計數器(binary counter)**
* 一個*n* 位元的二進位計數器是由*n* 個正反器所組成，計數範圍為0 ~ 2 *<sup>n</sup>* - 1

---
計數器分為兩種 ─ 漣波計數器與同步計數器  
在漣波計數器中，正反器的輸出轉變被當作是其他正反器的觸發來源  
換言之，其中一些或全部正反器的輸入*Clk* 會被觸發，但並非由共同的時脈脈波所觸發，而是由其他正反器的輸出轉變來觸發  
(可聯想為鎖鏈式的連續觸發)  
下面將介紹BCD漣波計數器，並說明其操作方式  

---
二進位漣波計數器是由一連串取補數正反器連接而成，即令每個正反器的輸出端連接至下一個較高階正反器的*Clk* 輸入  
存放最低有效位元的正反器接收外來的計數脈波  

這種互補式的正反器可經由將*JK* 正反器的兩輸入端連接在一起而得，或是使用*T* 型正反器  

第三種可能方式是使用*D* 型正反器，將其補數輸出連接至輸入*D* 即可  
※採用第三種方式時，輸入*D* 總是為目前狀態的補數，且在下一個時脈時使正反器輸出變補數  

下面即是兩個四位元的二進位漣波計數器之邏輯圖，分別使用了*T* 型正反器與*D* 型正反器：  
![File Crash!](https://i.imgur.com/BVnychn.jpg)  

每一個正反器的輸出依序連接至下一個正反器的*Clk* 輸入，存放最低有效位元的正反器則接受外來的計數脈波  

上圖(a)的所有正反器之*T* 輸入連接至固定的邏輯1，當輸入*Clk* 的信號通過時脈負緣時，會讓每一個正反器的輸出轉變  
※輸入*Clk* 前面的小圓泡表示正反器採負緣觸發  

若前一個正反器的輸出由1轉為0，則其連接的下一個正反器的輸入*Clk* 也會產生負緣轉變  

為了瞭解四位元的二進位漣波計數器的動作，可以參考下表所列的前九個二進位數字：  
![File Crash!](https://i.imgur.com/uVBk46S.jpg)  

從二進位0開始計數，依照每一個計數脈波輸入逐次加1，在15次計數以後，計數器回歸0以便重新計數  
每一個計數脈波輸入時，最低有效位元*A<sub>0</sub>* 狀態會變補，每當*A<sub>0</sub>* 由1轉為0時，*A<sub>1</sub>* 就會變補 **(更高階的有效位元通通以此類推)**  

舉例來說，現在考慮計數從0011轉變至0100
計數脈波輸入時，*A<sub>0</sub>* 會變補，即由1轉為0，觸發了*A<sub>1</sub>* ，使*A<sub>1</sub>* 也變補，同樣是由1轉為0  
*A<sub>1</sub>* 的變補也觸發了*A<sub>2</sub>* ，*A<sub>2</sub>* 由0轉為1，但因為整個系統是負緣觸發，因此這時的*A<sub>2</sub>* 不會觸發*A<sub>3</sub>* 變補

信號經過計數器時，就向漣波(漣漪、鎖鏈)一般，從此級傳至下一級，使正反器連續地每次轉變一個  

一個反向計數的二進位計數器，稱為**二進位下數計數器(binary countdown counter)**  
在下數計數器之中，每一個計數脈波輸入時，二進位計數即減1，從15開始計數，持續二進位遞減計數14,13,12......0，然後回復到15  

二進位下數計數器的計數順序表顯示每一個計數脈波輸入時，其最低有效位元狀態會被取補數  
對於其他位元而言，它的較低有效位元由0轉為1時，狀態才需要改變  

換言之，一個二進位下數計數器的邏輯電路圖可以與上面的兩個電路相同，只需要取消*Clk* 前的小圓泡(即改為正緣觸發)即可

如果堅持要用負緣觸發正反器的話，則須將每個正反器的*Clk* 輸入連接至前一個正反器的補數輸入( 即*Q'* )  
然後，當真正的輸出由0變為1時，其補數輸出會從1變0，進而如所需的將下一級正反器取補數  

---
一個十進位的計數器依照10個狀態的順序，並在計數至9之後回歸到0，這樣的計數器至少需要四個正反器來表示每一個十進位數字  

在十進位計數器中，狀態的順序是用二進位碼來表示，如果使用BCD碼則狀態圖的順序將如下所示：  
![File Crash!](https://i.imgur.com/HEWmGND.jpg)  

接著下圖是一個使用*JK* 正反器的BCD漣波計數器的邏輯電路圖：  
![File Crash!](https://i.imgur.com/DYJH6rr.jpg)  

計數器的四個輸出使用具有下標的符號*Q* 來表示 **(下標的數字恰好對應二進位權值)**  
注意：*Q<sub>1</sub>* 的輸出被連接到*Q<sub>2</sub>* 與*Q<sub>8</sub>* 的*Clk* ，且*Q<sub>2</sub>* 的輸出被連接到*Q<sub>4</sub>* 的*Clk*  

其中*J* 與*K* 輸入不是接到一個永遠為1的信號，就是接到其他正反器的輸出  

漣波計數器是一種非同步序向電路，影響正反器狀態轉變之信號會根據其由1變成0的方式而定  
計數器的動作可透過一系列的正反器轉變條件來說明，這些條件可藉由邏輯圖以及對*JK* 正反器動作的理解推導而得  

記得當*Clk* 從1變0時，若*J* = 1，則正反器被設置；若*K* = 1，則正反器重置(清除)  
若*J* = *K* = 1，則正反器轉為補數輸出(變補)；若*J* = *K* = 0，則正反器維持原狀態  

為了確認這些條件產生BCD漣波計數器所需的狀態順序，就必須證明正反器的狀態轉變，確實地如上面的狀態圖所規定的狀態順序改變  

每一個時脈脈波以後，*Q<sub>1</sub>* 改變狀態，只要*Q<sub>8</sub>* = 0，每次*Q<sub>1</sub>* 由1轉為0，最造成*Q<sub>2</sub>* 的狀態轉變為補數輸出  

當*Q<sub>8</sub>* = 1時，*Q<sub>2</sub>* 將維持在0  
當*Q<sub>2</sub>* 由1變為0時，*Q<sub>4</sub>* 會變補  

只要*Q<sub>2</sub>* 或*Q<sub>4</sub>* 為0，則*Q<sub>8</sub>* 維持在0  

當Q<sub>2</sub>* 與*Q<sub>4</sub>* 均為1，且*Q<sub>1</sub>* 由1轉為0時，*Q<sub>8</sub>* 就會變成補數輸出  
此時的*Q<sub>1</sub>* 的下一次轉變，*Q<sub>8</sub>* 將會被清除為0  

上面的BCD漣波計數器的邏輯圖就是一個十進位的計數器，能夠計數從0 ~ 9  
若要計算0 ~ 99，就需要兩個十進位的計數器；0 ~ 999則是三個，以此類推  

藉由串接BCD計數器可組成多位數的十進位計數器，下圖就是一個三位數的十進位計數器：  
![File Crash!](https://i.imgur.com/MF9vAF8.jpg)  

接到第二位數及第三位數的輸入來自於前一位數的*Q<sub>8</sub>*  
當某一位數的*Q<sub>8</sub>* 由1變為0時，表示它自身的位數由9回歸至0，同時也將觸發下一個更高階位數的計數器




<h2 id = "A2"> A2. 單字對證 </h2>

* 暫存器 ─ register
* 計數器 ─ counter
* 載入 ─ loading
* 更新 ─ updating
* 並列載入 ─ parallel load
* 傳輸延遲 ─ propagation delays
* 移位暫存器 ─ shift register
* 串列輸入 ─ serial input
* 串列輸出 ─ serial output
* 右移 ─ shift-right
* 左移 ─ shift-left
* 單向移位暫存器 ─ unidirectional shift register
* 雙向移位暫存器 ─ bidirectional shift register
* 通用移位暫存器 ─ universal shift register
* 正反器 ─ universal shift register
* 發射器 ─ transmitter
* 接收器 ─ receiver
* 並列至串列 ─ parallel-to-serial
* 串列至並列 ─ serial-to-parallel
* 二進位計數器 ─ binary counter
* 二進位下數計數器 ─ binary countdown counter

<h2 id = "A3"> A3. 後記與參考 </h2>
<h4>參考書目</h4>

* 數位邏輯設計 - 滄海書局：[https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212](https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212 "數位邏輯設計 - 滄海書局")
* Digital Design: With an Introduction to the Verilog HDL：[https://www.tenlong.com.tw/products/9780273764526](https://www.tenlong.com.tw/products/9780273764526 "Digital Design: With an Introduction to the Verilog HDL")

<h4>援引資料</h4>

* 維基百科： [https://zh.wikipedia.org/wiki/ASCII](https://zh.wikipedia.org/wiki/ASCII "維基百科")
