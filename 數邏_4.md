## 本章目標
>活用前面章節觀念，熟悉電路的分析與設計步驟，了解常見之標準組合電路

## 目錄
* [A1. 前言與聲明](#A1)
* [1. 組合電路](#1)
* [2. 分析步驟](#2)
* [3. 設計步驟](#3)
* [4. 二進位加法器-減法器](#4)
* [5. 十進位加法器](#5)
* [6. 二進位乘法器](#6)
* [7. 大小比較器](#7)
* [8. 解碼器](#8)
* [9. 編碼器](#9)
* [10. 多工器](#10)
* [A2. 單字對證](#A2)
* [A3. 後記與參考](#A3)

<h2 id = "A1"> A1. 前言與聲明 </h2>
在進入數位邏輯設計的同時，也意味著你將要開始以數位世界的思維與規則在思考各種觀念與問題，
 
請整理好思緒，別讓自己前後矛盾而混淆了許多簡單的觀念。另有以下幾點聲明須知：

* 本教學歡迎轉載分享，唯獨不得做為商業利益使用，內容援引之範例，其版權皆屬原作者所有
* 講義內容之安排係以國立臺北教育大學數位科技設計學系安排之課程內容為主，若有未提及之處，請善用網路資源
* [A2. 單字對證](#A2)中對於各項專有名詞之名稱將以參考書目為準，若有疑問，請善用網路資源
* 參考書目及其他援引資訊將列於[A3. 後記與參考](#A3)


<h2 id = "1"> 1. 組合電路 </h2>

* 數位系統的邏輯電路可能是組合的(combinational)或是序向的(squential)
* 組合電路的輸出僅由當下輸入的組合所決定
* 序向電路還有個儲存元件，儲存先前輸入的函數，因此序向電路的輸出需要考慮當下輸入的組合以及過去的輸入
* 此章節將先著重於組合電路的探討

---
組合電路由各種邏輯閘組成，可將已知輸入資料的二元資訊轉換成所需要的輸出資料。  
對於一個組合電路，在邏輯電路圖中可以用一個方塊來代替，同時擁有 *n* 個輸入與 *m* 個輸出  
在大多數情況下，來源與目的都是儲存暫存器，如果暫存器中**包含組合邏輯閘**，則整組電路必須視為**序向電路**

從前面無數個例子可以知道，對於*n*個變數，會有2*<sup>n</sup>* 種輸入組合  
每一種輸入組合，每個輸出變數都只有一種輸出值，因此組合電路可以用一個列出所有輸入組合之輸出值的真值表來指定  

組合電路也可以用 *m* 個布林函數去描述，每一個函數代表一個輸出變數。  
每一個輸出函數則使用 *n*個輸入變數來表示

如果覺得有些抽象的話，直接套入數字來說明，假設現在有3個輸入，2個輸出：  
那麼目前將會有8種輸入組合，對此，組合電路可以列出所有8種輸入組合的真值表的**「左半部」**(輸入部分)  

接著這兩個輸出內容必須分別繪製卡諾圖，求出各自的布林函數後，將結果安排進上面真值表的**「右半部」**(輸出部分，各自成行)

接下來的講義部分，我們將結合前面一至三章的概念，討論下面主題：  
1. 分析已知邏輯電路之行為  
2. 合成一個具有指定行為的電路

時至今日，已經有一些組合電路被廣泛應用於設計方面，這些電路被歸類為標準元件，也將會在下面陸續講解


<h2 id = "2"> 2. 分析步驟 </h2>

* 分析步驟就是要去決定該電路所要執行的函數
* 可以從一個已知的邏輯圖開始，用一組布林函數、真值表或電路操作的說明作為結束

---
要進行分析步驟，第一步是要確認該電路不是序向電路  
誠如前面所說，組合電路僅由當下輸入的組合所決定，**內部並不存在回授路徑或記憶元件**
<pre>
回授路徑是從第一個閘的輸出到第二個閘的輸入的連接，形成對第一個閘的部分輸入
數位電路終將回授路徑定義為序向電路，故在此章節暫時不會探討
</pre>

要從邏輯圖中得到輸出的布林函數，可以採取以下步驟：  
1. 利用任意的符號(盡量簡單且有意義，如 *T*, *F* )，將所有閘輸出表示為輸入變數的函數，對每一個閘輸出決定布林函數  
2. 將已標示為輸入變數的函數之閘，用之前已標示的閘再利用其他任意符號加以標示，得到這些閘的布林函數  
3. 重複第2點之過程，直到得出最後的輸出為止  
4. 利用先前定義的函數加以置換，最終就能得到輸入變數的輸出布林函數  

單看步驟多多少少還是會感到抽象，就以下面的組合電路進行說明：  
![File Crash!](https://i.imgur.com/wSCWVX3.jpg)  

這個電路的實際輸入變數只有*A*,*B*,*C*三種，輸出有兩個，另外在部分閘輸出各自標示了一個變數  
其中最容易推導出來的當屬*T<sub>1</sub>* , *T<sub>2</sub>* 與 *F<sub>2</sub>*，分別是：  
*T<sub>1</sub>* = *A* + *B* + *C*  
*T<sub>2</sub>* = *ABC*  
*F<sub>2</sub>* = *AB* + *AC* + *BC*  

接下來考慮閘輸出被定義的函數：  
*T<sub>3</sub>* = *F'<sub>2</sub>T<sub>1</sub>*  
*F<sub>1</sub>* = *T<sub>3</sub>* + *T<sub>2</sub>*  

最後為了得到*F<sub>1</sub>*，我們得進行置換(步驟4)  
*F<sub>1</sub>*  
= *T<sub>3</sub>* + *T<sub>2</sub>*  
= *T<sub>3</sub>* + *ABC*  
= (*AB* + *AC* + *BC*)*'*(*A* + *B* + *C*) + *ABC*  
= (*A'* + *B'*)(*A'* + *C'*)(*B'* + *C'*)(*A* + *B* + *C*) + *ABC*  
= (*A'* + *B'C'*)(*AB'* + *AC'* + *BC'* + *B'C*) + *ABC*  **(這行省略較多，注意結合律以及抵銷)**  
= *A'BC'* + *A'B'C* + *AB'C'* + *ABC*

當布林函數已知，真值表的推導將會相當簡單，如果要省略布林函數的推導，直接從邏輯圖獲得真值表，過程如下：  
1. 決定在電路中輸入變數的數目，並且在表中列出所有二進數字  
2. 將所選擇的閘輸出用符號標示  
3. 對於只是輸入變數函數的閘輸出，求出真值表  
4. 繼續對之前已經定義有值之函數的那些閘輸出求得真值表，直到所有輸出都被決定為止  

以上面的電路為例，其真值表最後會是：  
![File Crash!](https://i.imgur.com/u09q2Dz.jpg)  

同樣透過電路圖，先填完*T<sub>1</sub>* , *T<sub>2</sub>* 與 *F<sub>2</sub>*  
接著填完*F'<sub>2</sub>*，至此，剩餘的輸出就能以現有的資訊繼續推導，例如：  
*T<sub>3</sub>* = *F'<sub>2</sub>T<sub>1</sub>*  
那麼只需要找出*F'<sub>2</sub>* 與 *T<sub>1</sub>* 這兩行的數值進行AND就行了

<h2 id = "3"> 3. 設計步驟 </h2>

* 組合電路之設計，係從設計目的的規格的描述開始，結束於邏輯圖的完成
* 也可以由邏輯圖獲得一組簡化的布林函數

---
設計的過程含有以下步驟：  
1. 根據電路規格，決定「輸入」與「輸出」的個數，並且安排變數符號  
2. 推導出真值表，並定義輸入與輸出之間的關係  
3. 針對**每一個輸出**求出以輸入變數為函數之簡化的布林函數  
4. 繪製邏輯圖  

這裡我們以編碼轉換作為例子，不同的編碼之間的轉換相當泛用，且正好能作為上述步驟的說明  
現在嘗試將BCD碼轉換成超3碼 **(對於此兩種碼不熟悉的讀者可以參考前面章節)**

BCD碼是用四個位元去表示一個十進數數元，四個輸入分別代表「8,4,2,1」
超3碼則是針對8421碼加上0011，同樣需要四個數元去表現

因此在這個範例中：  
* BCD碼的四個數元做為輸入  
* 超3碼的四個數元作為輸出  
* 目標則是在過程中要執行加上0011的動作

至此，輸入與輸出的組合以及規律已經被我們掌握，故可完成真值表如下圖：  
![File Crash!](https://i.imgur.com/ARd00ql.jpg)  

這裡可能會有部分讀者有兩個疑問  
第一個疑問是，為何真值表指標是到9？  
因為BCD碼本身是用來表示十進數，因此不需要總和大於10的組合存在，故省略  

這時又迎來第二個疑問，那麼省略的那些組合該怎麼辦？  
很簡單，就是 **不理會條件**
  
真值表完成以後，就是針對每一個輸出求出布林函數啦！這裡就用卡諾圖來處理  
因為有四個輸出，所以我們需要繪製四個卡諾圖，再針對各自的情況，在對應的位置填入1  
完成後如下：  
![File Crash!](https://i.imgur.com/oluT8wh.jpg)  
由左至右，由上而下分別是：  
*z* = *D'*  
*y* = *CD* + *C'D'*  
*x* = *B'C* + *B'D* + *BC'D'*  
*w* = *A* + *BC* + *BD*  

另外，我們還能針對上面的布林函數進行一些合併或擴充，以達到邏輯圖的方便繪畫：  
*z* = *D'*  
*y* = *CD* + *C'D'* = *CD* + (*C* + *D*)*'*  
*x* = *B'C* + *B'D* + *BC'D'* = *B'*(*C* + *D*) + *BC'D'* = *B'*(*C* + *D*) + *B*(*C* + *D*)*'*  
*w* = *A* + *BC* + *BD* = *A* + *B*(*C* + *D*)

發現了嗎？輸出是*C* + *D*的OR閘可以實現具有三個輸出的一部分
透過這樣的編排，能讓一些閘變得公用，也可以省略重複性過高的閘，增加效率

最後只需要繪製成電路圖就是我們需要的答案，也就是組合電路：  
![File Crash!](https://i.imgur.com/Q6e5fEw.jpg)


<h2 id = "4"> 4. 二進位加法器-減法器 </h2>

* 了解何謂半加法器與全加法器
* 將執行效率、進位、溢位等等納入考量

---
數位計算機最基本的算術運算，即為兩個二進位位元的相加，總共四種：  
0+0 = 0、0+1 = 1、1+0 = 1、1+1 = 10  
上述最後一種運算得到了二位數，其中較高的有效位元稱為**進位(carry)**  

當兩數相加出現較高的有效數元時，該進位必須加在下一對更高有效數元上。  
實現兩個位元相加的組合電路稱為**半加法器(half adder)**  
執行三個位元(兩個有效數元，一個先前進位數元)相加的組合電路，稱為**全加法器(full adder)**  
※兩個半加法器組合 = 一個全加法器  

在實作的順序上，我們首先完成半加法器，進而發展成全加法器  
*n*個全加法器串聯即可得到產生*n*位元數字之二進數加法器  至於減法器可以透過取補數而得

---
半加法器的電路，需要兩個二進位輸入以及兩個二進位輸出，其中兩個輸出分別是和(*S*)與進位(*C*)，輸入暫定為 *x*，*y*  
半加法器的真值表如下圖：  
![File Crash!](https://i.imgur.com/rtVbMcv.jpg)  
至於簡化過後的布林函數為：  
*S* = *x'y* + *xy'* = *x* ⊕ *y*  
*C* = *xy*  

邏輯電路圖可以用下列的形式實現，同時可以用來說明兩個半加法器構成全加法器：  
![File Crash!](https://i.imgur.com/1lRQIxd.jpg)  

---
全加法器為一個處理三輸入位元算數的組合電路，具有三個輸入和兩個輸出，輸出部分依樣保持著和(*S*)與進位(*C*)，輸出為*x*，*y*，*z*  
其中*x*，*y*代表要相加的有效位元，*z*代表從前面較低有效位置傳來的進位

對此，我們重新擬定一份全加法器的真值表：  
![File Crash!](https://i.imgur.com/QlgdGON.jpg)  

而布林函數相較於半加法器也複雜許多，因此先分別繪製出卡諾圖以供參考：  
![File Crash!](https://i.imgur.com/qJOyryE.jpg)
![File Crash!](https://i.imgur.com/y1NENrc.jpg)  
(左為*S*，右為*C*)

得到布林函數為：  
*S* = *x'y'z* + *x'yz'* + *xy'z'* + *xyz*  
*C* = *xy* + *xz* + *yz*  

對於上面的布林函數，我們當然可以直觀地用AND閘與OR閘，且輸入可以為補數形式地去完成  
但是如果使用互斥-OR閘，就能讓整個組合電路更加有效率，組合電路如下：  
![File Crash!](https://i.imgur.com/lJzcp4U.jpg)  

這個形式的組合電路就能明顯看出全加法器是由兩個半加法器構成

---
**二進位加法器(binary adder)** 是一個用來產生兩個二進位數字算術和的電路，他可以用全加法器串接的方式進行連接，再把每一個全加法器的輸出進位連接到下一個全加法器， *n* 位元數字就需要 *n* 個全加法器，或者是一個半加法器連接一串 *n*-1 個全加法器  

整體概念如下：  
![File Crash!](https://i.imgur.com/Z4SCXR7.jpg)  

FA為全加法器(Full Adder)的縮寫，那如果要使用半加法器的話，就得把半加法器替換掉最右邊的(第一個)全加法器，因為**第一個位元運算不會有進位的情況**，而這張概念圖的形式，又可稱為**四位元二進位漣波加法器**

我們用一組數字與類似數學直式的格式來說明，假設*A* = 1011， *B* = 0011：  
![File Crash!](https://i.imgur.com/vGd6zsU.jpg)  

搭配上圖，即可輕鬆地理解漣波加法器的概念，只可惜這樣的電路還不是一個最有效率的辦法，之後會繼續解釋。

---
前面或多或少提過，而且不難想像，訊號在通過邏輯閘時會經過處理，多多少少會產生處理時間，也就是**延遲**，可以得到下面算式：  
總傳播時間 = (一個典型閘傳播延遲) x (電路中閘的階數)  

那麼現在回頭考慮漣波加法器，倘若計算兩個位數很大的二進位數相加，上面的設計方式並非首選，最主要的原因是：  
**和輸出的每一位元都取決於輸入進位的值**  
比如說，要計算出*S*<sub>3</sub> ，就必須等之前的運算作結束，得到 *C*<sub>3</sub> 以後方可計算，這當中延遲的時間不可小覷  
而在得到*C*<sub>3</sub>之前，*S*<sub>3</sub>將會是浮動值，這更是讓設計者多一份難以掌握的變因，當然希望避免  

現在我們將前面的全加法器邏輯圖換個標記方式如下：  
![File Crash!](https://i.imgur.com/4v6wWPp.jpg)

輸入和輸出變數用下標 *i* 來表示它在加法器的層級  
如果加法器中有四個全加法器，則*C*<sub>0</sub> 到 *C*<sub>4</sub>之輸出進位*C*<sub>4</sub>會有2*4 = 8個閘階層  
**對於n位元的加法器，進位從輸入到輸出傳播共有2n個閘階層**  


進位傳播時間是加法器的重要屬性，如何減少進位傳播延遲時間是一門課題，方法大致有二：  
1. 使用較少延遲的快速閘，但對於實際電路而言仍有一定極限  
2. 增加裝置複雜度，來減少進位延遲時間  

在平行加法器中有幾個方法可以減少進位傳播時間，最泛用的是應用**前瞻進位邏輯(carry lookhead logic)** 的原理

從上面的圖片可以看到：  
*P<sub>i</sub>* = *A<sub>i</sub>* ⊕ *B<sub>i</sub>*  
*G<sub>i</sub>* = *A<sub>i</sub>B<sub>i</sub>*  

輸出部分則表示為：  
*S<sub>i</sub>* = *P<sub>i</sub>* ⊕ *C<sub>i</sub>*  
*C<sub>i+1</sub>* = *G<sub>i</sub>* + *P<sub>i</sub>C<sub>i</sub>*  

*G<sub>i</sub>* 稱為**進位產生(carry generate)** ，且不管*C<sub>i</sub>* 為何，它在*A<sub>i</sub>* 與 *B<sub>i</sub>*
同時為1時，會產生一個進位1  


*P<sub>i</sub>* 稱為**進位傳播(carry propagate)**，因為它可以決定一個進位是否由 *i* 級傳播至 *i*+1級  
現在，我們對每一級的進位輸出寫出其布林函數，並且用先前的方程式去取代每一個值，得到：  
*C<sub>0</sub>* = 輸入進位  
*C<sub>1</sub>* = *G<sub>0</sub>* + *P<sub>0</sub>C<sub>0</sub>*  
*C<sub>2</sub>* = *G<sub>1</sub>* + *P<sub>1</sub>C<sub>1</sub>* = *G<sub>1</sub>* + *P<sub>1</sub>*(*G<sub>0</sub>* + *P<sub>0</sub>C<sub>0</sub>*) = *G<sub>1</sub>* + *P<sub>1</sub>G<sub>0</sub>* + *P<sub>1</sub>P<sub>0</sub>C<sub>0</sub>*  
*C<sub>3</sub>* = *G<sub>2</sub>* + *P<sub>2</sub>C<sub>2</sub>* = *G<sub>2</sub>* + *P<sub>2</sub>G<sub>1</sub>* + *P<sub>2</sub>P<sub>1</sub>G<sub>0</sub>* + *P<sub>2</sub>P<sub>1</sub>* *P<sub>0</sub>C<sub>0</sub>*
 
如果把上面的代號都當作單純的輸入來看的話，那每一個布林函數都是積項和形式，繪製成電路圖如下：  
![File Crash!](https://i.imgur.com/dVix3PW.jpg)  

注意，這個複雜的電路所要呈現的，是*C<sub>3</sub>* 不必等候*C<sub>2</sub>* 與*C<sub>1</sub>* 才能傳播；事實上，**三者是同時傳播**  
這就是所謂的 ─ **減少加法器耗用時間，增加操作效率，但同時也增加了複雜度與硬體成本**  

具有前瞻進位架構的四位元加法器結構圖如下：  
![File Crash!](https://i.imgur.com/VCIMnXZ.jpg)

(中間的大型區塊正是剛剛的邏輯圖加以延伸成四位元加法器後的概括區域)  
如此一來，輸出的*S<sub>1</sub>* 到*S<sub>3</sub>* 或是進位，都具有相同的延遲時間

---
還記得無號二進位數的減法，可以透過補數來完成嗎？**(參考第一章)**  
對於 *A* - *B* 的減法電路而言，包含一個具有在每一筆資料輸入*B* 與全加法器相對應的輸入之間都放置一個反相器的加法器  
聽起來抽象嗎？簡單來說，就是在*B*輸入之前先進行一次**判斷**，這個「判斷」會決定 *B* 是否**維持原輸入或是形成補數**  

執行減法時，令*C<sub>0</sub>* = 1，這樣的結果將會是「*A* + *B*之1的補數，再加1」的運算，相當「*A* + *B*之2的補數」  
對於無號數，若*A* ≥ *B*，則得到 *A* - *B*  ；若 *A* < *B*，則得到 *B* - *A*之2的補數  
對於有號數，只要沒有**溢位(overflow)**，結果就會是 *A* - *B*  

加法與減法運算可以共用一個二進位加法器電路，只要在每個 *B* 輸入全加法器之前多一個互斥-OR判斷即可達成，邏輯圖如下：  
![File Crash!](https://i.imgur.com/dQp3PzU.jpg)  

變數 *M* 可以被稱為控制運算的模式選擇，當 *M* = 0，電路為加法器；反之則為減法器  
全加法器前的每一個互斥-OR接收著 *M* 與*B<sub>i</sub>*  
當*M* = 0時，可得*B<sub>i</sub>* ⊕ 0 = *B<sub>i</sub>*  
全加法器接收*B*的原值，且輸入進位 *C<sub>0</sub>* = 0，電路執行 *A* + *B*  

換言之，當*M* = 1時，*B<sub>i</sub>* ⊕ 1 = *B'<sub>i</sub>*，且 *C<sub>0</sub>* = 1  
形成了「*A* + *B* 之1的補數，再加1」的運算，相當於「*A* + *B*之2的補數」  

另外還有一個輸出*V*的互斥-or閘，是用來偵測是否溢位用的

---
兩個 *n*數元的數字相加產生 *n*+1個數元時，我們稱為溢位(無論是無號數或有號數皆成立)  
對於長期使用紙筆計算的我們來說自然不太可能意識到這個問題，但如果是計算機，或是現在的加法器，溢位的問題就有可能浮現  
對此，許多計算機偵測到溢位發生時，會有對應的正反器設定用來讓使用者可以制止  


溢位的偵測取決於數字被當作有號數或無號數  
無號數相加時，溢位是由超過最高有效位元位置之末端進位來偵測  
有號數則較為不同且必須更加留意 ─ 最左邊位元通常是表示符號，且負數為2的補數  
有號數相加時，符號位元被當作數字的一部分，故末端進位不表示是溢位  

溢位的可能出現條件是 **「兩數皆為正/負數時相加」**  
如果兩數是一正一負的相加，則最終結果一定會介於兩數之間，不可能溢位

溢位的條件可以利用觀察進入符號位元位置的進位，以及自符號位元位置之進位輸出來偵測  
如果兩個**進位不相等**，則產生溢位，例子可以參考四位元加法器-減法器的圖的 *V*  

若輸出1，溢位即被偵測到，要讓動作正確，則2的補數必須利用取1的補數再加1去計算

以四位元加法器-減法器的圖為例  
如果視作無號數，位元*C*在加法後偵測一個進位；或是減法後偵測到一個借位  

如果視為有號數，則位元*V*會偵測到溢位，進行運算後，如果*V* = 0，則沒有溢位產生  
若*V* = 1,則運算結果包含了*n* +1個位元，其中只有*n*個位元被容納在結果之中，而最左邊 **(用來表示正負號的)** ，第 *n*+1個位元已經被移出位置外


<h2 id = "5"> 5. 十進位加法器 </h2>

* 本節將檢視一個BCD編碼的十進位加法器

---
對於一個基本的**十進數加法器(decimal adder)**,至少需要9個輸入與5個輸出  
※因為每個數元需要四個位元編碼，除此之外還需要一個輸入及輸出進位  

現在考慮兩個帶有先前進位的十進數數元在BCD中的算術加法
假設兩數皆為最大值9，來自先前進位亦是最大值1，則此級的輸出總和至多為19(其中1也將做為下一級的輸入進位)  

現在假設我們擁有兩個BCD數元，準備加進四位元的二進位加法器，則加法器將會產生二進位形式的和，請參照下表：  
![File Crash!](https://i.imgur.com/RT7pije.jpg) 

K與C分別為各自的進位符號，可以看到兩種表現形式在十進位 = 10以後開始出現歧異  
複習前面的章節會知道，大於10以後的BCD和需要加上0110才能正確顯示  

所以說，設計出十進位加法器的重點，在於如何找到規則並正確地轉換二進位與BCD數元  

參照上面的表格，當二進位和等於或小於1001時，BCD和的顯示仍為正確，換言之 ─ **不需經過任何轉換**  
但是如果大於1001，我們便會得到錯誤的BCD和；我們必須再加上二進數的6(即0110)，才能得到正確的BCD表示，同時得到一個必要的輸出進位  

以上，我們得知設計此加法器的核心概念 ─ **判斷二進位和的值，決定是否需要加上0110**  

現在讓我們根據上面的表格來決定哪些特徵需要被「偵測」到  
*K*=1的自然是需要被偵測的(即十進位16 ~ 19)，其他組合則是*Z<sub>8</sub>* =1時會被偵測  
但是這樣卻出現一個問題 ─ 1000與1001也會被偵測(即十進位8 ~ 9)，該怎麼解決？  
既然眼前兩個進位不能解決問題，就繼續朝下面的進位動腦筋，更進一步指定*Z<sub>4</sub>* 或*Z<sub>2</sub>* 必須為1，這樣就過濾完成啦！  

最終推導出布林函數為：  
*C* = *K* + *Z<sub>8</sub>Z<sub>4</sub>* + *Z<sub>8</sub>Z<sub>2</sub>*  

當*C*=1時，則需要將0110加進二進位和，藉此轉換出正確的BCD表示，並提供一個輸出進位給下一級  

一個BCD加法器可以執行兩個BCD數元的相加，如下圖所示：  
![File Crash!](https://i.imgur.com/lHfGi8f.jpg)  

首先在上面的四位元加法器相加，產生二進位和  
如果輸出進位為0，則二進位和不用再加值  
若輸出進位為1，則二進位0110會經由下面的加法器加到二進位和  

至於從下面產生的輸出進位可以忽略，因為輸出進位端已經用到  
十進位並列加法器用以將*n*個十進位數元做相加，需要*n*級的BCD加法器，而輸出進位必須連接到高一級的輸入進位



<h2 id = "6"> 6. 二進位乘法器 </h2>

* 二進位數字的乘法與十進數處理乘法的方式一樣
* 用數學直式書寫的格式能夠幫助理解

---
被乘數從最小有效位元開始做乘法運算，每一個乘法都形成一部分之乘積  
最後的乘積式將所有部分成績加總而得  

現在考慮兩個二位元數字*A*與*B*的乘法，位元分別表示為 *A<sub>1</sub>A<sub>0</sub>*以及*B<sub>1</sub>B<sub>0</sub>*  
得到的積為 *C<sub>3</sub>C<sub>2</sub>C<sub>1</sub>C<sub>0</sub>*  
用直式來表示如下：  
![File Crash!](https://i.imgur.com/T1QvsZw.jpg)
![File Crash!](https://i.imgur.com/uBYOpXN.jpg)  

因為二進位制下只有數字1或0，做乘法計算時可當作執行AND運算，而兩個部分乘積則利用兩個半加法器(Half Adder)做相加，如上圖  

具有更多位元的二進位乘法器組合電路可以用類似的概念來建構，對於*J* 個乘數位元與*K* 個被乘數位元，將會需要( *J*×*K* )個AND閘，以及(*J*-1)*K*位元的加法器，藉此產生( *J*+*K* )位元的乘積  

現在考慮一個乘法器電路以完成四位元的二進數與三位元的二進數的乘法，令被乘數為*B<sub>3</sub>B<sub>2</sub>B<sub>1</sub>B<sub>0</sub>*，乘數為*A<sub>2</sub>A<sub>1</sub>A<sub>0</sub>*  
此時*K* = 4，*J* = 3，因此我們需要12個AND閘，兩個四位元加法器去產生一個七位元的乘積，完成的電路圖如下：  
![File Crash!](https://i.imgur.com/kpFXjWQ.jpg)



<h2 id = "7"> 7. 大小比較器 </h2>

* 兩個*n*位元的比較電路在真值表中有2<sup>2*n*</sup>個輸入

---
考慮兩個具有四位元數字*A*與*B*，並且分別表示如下：  
*A* = *A<sub>3</sub>A<sub>2</sub>A<sub>1</sub>A<sub>0</sub>*  
*B* = *B<sub>3</sub>B<sub>2</sub>B<sub>1</sub>B<sub>0</sub>*  

倘若所有成對的有效數元相等，例如*A<sub>3</sub>* = *B<sub>3</sub>*，*A<sub>2</sub>* = *B<sub>2</sub>*......，則兩數相等  
當這些數字為二進制時，數元非1即0，因此每一組成對的數元之相等性可以被表示成具有互斥-NOR(XNOR)的邏輯函數：  
*x<sub>i</sub>* = *A<sub>i</sub>B<sub>i</sub>* + *A'<sub>i</sub>B'<sub>i</sub>* ，其中*i* = 0,1,2,3  

只有在位置*i*之數元對相等時，*x<sub>i<sub/>* = 1 **(兩個數字的該位置皆為1或0)**  
那麼如果要讓*A* = *B*的等式存在，勢必要讓所有的*x<sub>i<sub/>* 相等，那麼可以寫作：  
( *A* = *B* ) = *x<sub>3</sub>x<sub>2</sub>x<sub>1</sub>x<sub>0</sub>*  

換言之，只有兩個數字的所有數元對相等時，( *A* = *B* )才等於1，亦即成立  
要決定*A*相對於*B*的大小關係，要從最高有效位置開始檢查，若該有效位置的兩個數元相等，就進行次高的有效位置之檢查，以此類推  

若相對應的數元*A* = 1且 *B* = 0，則*A* > *B* ；反之如果*A* = 0且 *B* = 1，則*A* < *B*，至於連續的比較可以利用兩個邏輯上的布林函數去表示：  
( *A* > *B* ) = *A<sub>3</sub>B'<sub>3</sub>* + *x<sub>3</sub>A<sub>2</sub>B'<sub>2</sub>* + *x<sub>3</sub>x<sub>2</sub>A<sub>1</sub>B'<sub>1</sub>* + *x<sub>3</sub>x<sub>2</sub>x<sub>1</sub>A<sub>0</sub>B'<sub>0</sub>*  

( *A* < *B* ) = *A'<sub>3</sub>B<sub>3</sub>* + *x<sub>3</sub>A'<sub>2</sub>B<sub>2</sub>* + *x<sub>3</sub>x<sub>2</sub>A'<sub>1</sub>B<sub>1</sub>* + *x<sub>3</sub>x<sub>2</sub>x<sub>1</sub>A'<sub>0</sub>B<sub>0</sub>*

當*A* > *B* 或 *A* < *B* 時，符號(*A* > *B*) 及 (*A* < *B*)的二進位輸出變數將會分別等於1，邏輯電路可參考下圖：  
![File Crash!](https://i.imgur.com/jqVqHD3.jpg)

四個*x*輸出是由互斥-NOR電路所產生，並且應用到一個AND閘而得到輸出的二進位變數( *A* = *B* )



<h2 id = "8"> 8. 解碼器 </h2>

* 數位系統中，分離性的資料元素由二進位碼來表示
* 一個*n* 位元的二進位碼能夠表示到2 *<sup>n</sup>* 種編碼的分離性資料元素

---
**解碼器(decoder)** 是一個用來使二進位資料從*n* 條輸入線轉換到最多是2 *<sup>n</sup>* 條獨特輸出線的組合電路  
其中如果*n* 位元編碼資料有未使用到的組合，解碼器的輸出就有可能少於2 *<sup>n</sup>* 個  

以下介紹的解碼器稱為*n*到*m* 線解碼器，其中*m*≤2 *<sup>n</sup>*  
最終目的是產生*n* 個輸入變數之2 *<sup>n</sup>* (或更少)的全及項  

現在考慮下圖的三對八解碼器之邏輯電路：  
![File Crash!](https://i.imgur.com/73GSSbx.jpg)  

這個解碼器的運作方式可以參考下面的真值表，對於每一個輸出都只會有一個輸出為1，其他皆為0：  
![File Crash!](https://i.imgur.com/PSEXpdd.jpg)  

有些解碼器可以用NAND閘來完成，因為NAND閘可以產生一個反向輸出的AND運算，使它們在補數形式中產生解碼器的全及項更經濟  
並且在解碼器中還包含一個(或更多)的 **致能(enable)** 輸入來控制電路操作  

一個利用NAND閘建立且具備致能輸入的二對四解碼器，其邏輯電路可以設計如下：  
![File Crash!](https://i.imgur.com/fZwtNx7.jpg)  

此電路除了具有補數輸出，還有一個補數的致能輸入，當*E* = 0時，致能整個解碼器，詳細的真值表可以參考上表  
在任何時間點，只有一個輸出為0，而當下為0的輸出，正代表著*A*與*B*所選擇的全及項  

但是當*E* = 1時，**電路禁能(disable)**，此時無關輸入，所有輸出皆為1且沒有全及項被選擇  
一般而言，解碼器可能操作補數或非補數的輸出，致能輸入可以使用0或1信號來激發  


具有致能輸入的解碼器可以被功能化為**解多工器(demultiplexer,又稱DeMux)** ─ 是一個從單一線接收資料，並將它指向2*<sup>n</sup>* 條可能輸出線之其中一條上的電路，特定輸出的選擇是由*n*條選擇線的位元組和來控制  

以上圖為例，如果把*E*當成一條資料輸入線且*A*與*B*,作為選擇輸入時，就可以被功能化為一對四解多工器  

單一輸入*E*有一條路徑連接到所有四個輸出，但是這個輸出資料只能指向由兩條選擇線*A*與*B*之二進位組合所指定的唯一輸出線  

聽起來有點抽象，直接舉例說明會比較好一些：  
例如選擇線*A* = 1，*B* = 0，則*D<sub>2</sub>*將會與輸入*E* 的值相同(皆為0)，其餘以此類推，可以透過上面的真值表查證,也因為解碼器與解多工器的操作可以透過相同的電路組成來取得，所以一個具有致能輸入的解碼器也稱作**解碼器─解多工器(decoder-demultiplexer)**

具有致能輸入的解碼器可以連接起來形成一個更大的解碼器電路  
下面的電路圖就象徵著為具有致能輸入的兩個三對八解碼器連接形成一個四對十六線解碼器：  
![File Crash!](https://i.imgur.com/ibKNmMc.jpg)  

當*w* = 0時，上面的解碼器被致能，而另一個被禁能，且上面的解碼器輸出的八個全及項為0000 ~ 0111  
反之*w* = 1時,下面的解碼器被致能，而另一個被禁能，此時下面的解碼器輸出為1000 ~ 1111  

這個例子旨在說明解碼器以及其他組合邏輯元件致能輸入的用處  
一般來說，對於要它們結合成具有更多輸入與輸出之相同函數的目的,致能輸入用來相互連接兩個(或更多)個標準元件是一個極其方便的特性

---
*n* 個輸入變數的解碼器可以提供2 *<sup>n</sup>* 個全及項  
解碼器的每一個以確認輸出均只與輸入位元的一種獨特形式有關  
也因為任何的布林函數均可以表示成全及項和的形式，我們可以利用解碼器去產生全及項以及一個額外的OR閘來形成邏輯之和  

利用上述的方法，任何具有*n*個輸入,*m* 個輸出的邏輯組合電路皆可以用一個*n*對*2<sup>n</sup>* 線解碼器及*m*個OR閘來實現  

利用解碼器以及OR閘實現一個組合電路的步驟需要將電路的布林函數表示成全及項和的形式  
解碼器即可被選擇來產生輸入變數的所有全及項。每一個OR閘的輸入是根據每個函數所列的全及項而從解碼器中的輸出做選擇  

聽起來抽象，但是正巧可以透過全加法器來作舉例說明：  
參考[全加法器的真值表](#4)，我們可以得到此組合電路以全及項和的形式可表示為：  
*S*(*x*,*y*,*z*) = Σ(1,2,4,7)  
*C*(*x*,*y*,*z*) = Σ(3,5,6,7)  

三個輸入形成八個全及項，因此需要一個三對八解碼器，如下圖：  
![File Crash!](https://i.imgur.com/k7Jj9Cg.jpg)  

一個具有一長串全及項的函數需要一個具有大量輸入的OR閘  
一個函數若有*k*個全及項，其補數形式*F'*可以用2*<sup>n</sup>* - *k* 個全及項來表示  

如果一個函數的全及項數目大於2 *<sup>n</sup>* / 2，則*F'* 可以用較少的全及項來表示  
如果是上述的情況，優點是可以用NOR閘來總和*F'* 的全及項  

NOR閘的輸出會將這個和取補數，並且產生正常的輸出*F*  

<h2 id = "9"> 9. 編碼器 </h2>

* 編碼器(encoder)是一個用來執行解碼器之反向操作的電路
* 一個編碼器有2*<sup>n</sup>* (或更少)條輸入線以及*n* 條輸出線

---
編碼器說穿了，就是相對於解碼器的存在，如同一個彙集體  
現在考慮一個八進位對二進位編碼器，真值表如下：  
![File Crash!](https://i.imgur.com/n8hbMgw.jpg)  

編碼器可以使用OR閘實現  
輸入八進位數元是1,3,5或7時，輸出*z* 為1；  
八進位數元是2,3,6或7時，輸出*y* 為1；  
八進位數元是4,5,6或7時，輸出*x* 為1  

上述三行可以用下面的輸出布林函數：  
*z* = *D<sub>1</sub>* + *D<sub>3</sub>* + *D<sub>5</sub>* + *D<sub>7</sub>*  
*y* = *D<sub>2</sub>* + *D<sub>3</sub>* + *D<sub>6</sub>* + *D<sub>7</sub>*  
*x* = *D<sub>4</sub>* + *D<sub>5</sub>* + *D<sub>6</sub>* + *D<sub>7</sub>*  

而編碼器存在著一個限制，那就是任何時間點只能有一個輸入為1，如果同時有兩個以上的輸入為1就會出現一個存有爭議的輸出組合  
為了解決這個爭議性，編碼器需要設立一個輸入優先權以確保輸入只有一個被編碼  

假如以下標數字的大小作為優先權的依據，那麼如果*D<sub>2</sub>* 與*D<sub>5</sub>* 同時為1，輸出會是101  

另一個具有爭議性是所有輸入為0時，所有輸出皆為0，但是這樣的輸出結果與*D<sub>0</sub>* = 1時相同，這個問題可以透過提供一個更多輸出來指出至少有一個輸入是1來解決

---
**優先權編碼器(priority encoder)** 是一個包含優先權功能的編碼邏輯電路  
一個四─輸入優先權編碼器的真值表可以表示如下：  
![File Crash!](https://i.imgur.com/0VLNQuz.jpg)  

*V*是第三個輸出，是一個**有效(valid)位元指示器**  
當所有輸入為0時，輸出為0；有一個(或更多)輸入為1時，輸出為1

<pre>
注意上面的真值表：
輸出部分的X是不理會條件
而輸入部分則是省略的形式而非不理會條件，若要完整列出則會有16個全及項
例如：X100代表著1100與0100兩個全及項
</pre>

根據上面的真值表進行解讀，下標的數字越大就具有越高的優先權  
*D<sub>3</sub>* 擁有最高的優先權，因此當*D<sub>3</sub>* = 1時，可以無視其他輸入，輸出*xy* = 11  
*D<sub>2</sub>* 的優先權次之，當*D<sub>3</sub>* = 0且*D<sub>2</sub>* = 1時，便可以無視剩餘的輸入，輸出*xy* = 10，其餘以此類推  

化簡上述*x*與*y*的卡諾圖如下：  
![File Crash!](https://i.imgur.com/Pt90496.jpg)
![File Crash!](https://i.imgur.com/3F0KDrG.jpg)  

對於輸出*V*的條件是所有輸入變數的一個OR函數，所有布林函數如下：  
*x* = *D<sub>2</sub>* + *D<sub>3</sub>*  
*y* = *D<sub>3</sub>* + *D<sub>1</sub>**D'<sub>2</sub>*  
*V* = *D<sub>0</sub>* + *D<sub>1</sub>* + *D<sub>2</sub>* + *D<sub>3</sub>*  

最後根據布林函數的結果去完成優先權編碼器的邏輯電路：  
![File Crash!](https://i.imgur.com/FGM9NzW.jpg)



<h2 id = "10"> 10. 多工器 </h2>

* 多工器，可寫作MUX，為*n*對1結構
* 解多工器，可寫作DEMUX，為1對*n*結構

---
**多工器(multiplexer)** 是一個由許多條輸入線選擇一條二進位資料並且導向單一輸出線的邏輯組合電路  
一般而言，有2 *<sup>n</sup>* 條輸入線及*n* 條選擇線，而選擇線的位元組合可以決定哪一條輸入被選擇  

一個最單純的二對一線多工器如下面左圖：  
![File Crash!](https://i.imgur.com/2DiLO9i.jpg)  

當*S* =0時上面的AND閘被致能讓*I<sub>0</sub>* 得以輸出  
反之*S* = 1時，下面的AND閘被致能，輸出*I<sub>1</sub>*  

一般來說，多工器的方塊圖會是上面又圖的模樣，大致上是個梯形  


現在考慮一個四對一線多工器，繪製成邏輯圖如下：  
![File Crash!](https://i.imgur.com/Zco2Osq.jpg)  

*I<sub>0</sub>*到*I<sub>3</sub>* 分別被輸入進四個AND閘裡，選擇線*S<sub>0</sub>* 與*S<sub>1</sub>* 被用來選擇特定的AND閘，  
每一個AND閘再被輸入進一個OR閘提供單一輸出，下圖亦有表格提供給讀者查照  

例如現在讓選擇線*S<sub>0</sub>S<sub>1</sub>* = 10，那麼只有與*I<sub>2</sub>* 相關的那個AND閘會正常輸出，其餘皆為0，經過OR閘以後的單一輸出便會是*I<sub>2</sub>*  

這種從許多輸入中選擇其一再引導至輸出線上的動作，讓多工器又可被稱為**資料選擇器(data selector)**  

通常，一個2 *<sup>n</sup>* 對1的多工器是由一個*n* 對2 *<sup>n</sup>* 解碼器透過將此2 *<sup>n</sup>* 條輸入線中之每一條個別輸入進每一個AND閘，所有AND閘輸出再彙整進一個OR閘而得，多工器的大小取決於它的資料輸入線2 *<sup>n</sup>* 與單一輸出線的數量  


如同解碼器一般，多工器可能具有致能輸入來控制單元的操作  
換言之，當致能輸入在不作用狀態(禁能)時，輸出無效；在作用狀態(致能)時，電路就會是一個正常運作的多工器  


多工器可以和具有共通的選擇輸入結合，提供更多位元選擇邏輯，例如下圖的四重式二對一線多工器：  
![File Crash!](https://i.imgur.com/Zqs6mmX.jpg)  

這個電路內含四個多工器，每個多工器可以選擇兩條輸入線之一條  
當*Y<sub>0</sub>* 被輸出時，其值有可能是*A<sub>0</sub>*或*B<sub>0</sub>* ，其餘以此類推  
選擇線*S* 可以從四個多工器之中選擇一個，而致能*E* 必須是有作用  


但是以上面的例子而言，雖然包含四個二對一多工器，但是設計人員比較喜歡將其作為一個**用來選擇兩個四位元資料線組合之一**的電路  

並且可以從圖中的表格中得知，當*E* = 1時無視輸入，輸出全為0  
當*E* = 0且*S* = 0時，四個*A* 輸入會有一條路徑連接到四個輸出  
當*E* = 0且*S* = 1時，四個*B* 輸入會有一條路徑連接到四個輸出  

---
現在來說明如何利用一個具有*n* - 1個選擇輸入之多工器來實現一個*n* 變數布林函數較為有效的方法  
將函數最前面之*n* - 1個變數連接到多工器的選擇輸入上，剩下的單一變數作為資料輸入  

現在假設單一變數以 *z*來表示，那麼多工器的資料輸入將會是*z*,*z'*,1或0，然後考慮下面的布林函數：  
*F*(*x*,*y*,*z*) = Σ(1,2,6,7)  

這個三變數布林函數可以透過下面的電路圖實現：  
![File Crash!](https://i.imgur.com/5AUKmLe.jpg)  

先將*x*和*y*加到選擇線上(*x*對*S<sub>1</sub>*，*y*對*S<sub>0</sub>*)  
資料輸入線的值由函數的真值表而定(上圖左)  

當*xy* = 00時，輸出*F* = *z*，我們也可以用類似的方式求得*xy* = 01,10,11時所需要連接的資料輸入線1~3  

從這個例子得知，對於利用一個具有*n* - 1個選擇輸入以及2<sup>*n* -1</sup>資料輸入多工器來實現任何*n*變數的布林函數的一般步驟是：  
1. 為布林函數列出真值表  
2. 表中最前面*n* - 1個變數加入至多工器的選擇輸入中(如上面的*x*對*S<sub>1</sub>*，*y*對*S<sub>0</sub>*)  
3. 對於每一個選擇變數的組合，求出輸出值作為最後一個變數的函數，通常為0，1，變數，變數之補數的其中一種  
4. 最後將這些值以適當的次序加至資料輸入  

我們搭配下面的例子做說明：  
*F*(*A*,*B*,*C*,*D*) = Σ(1,3,4,11,12,13,14,15)  

完成的真值表與電路圖如下：  
![File Crash!](https://i.imgur.com/fc6jKid.jpg)  

這個例子中，我們讓變數*A*,*B*,*C*分別加入到選擇輸入*S<sub>0</sub>*至*S<sub>3</sub>* 中，此即完成第1與2步驟    
那麼輸出值就會是*D*,*D'*,0或1，接著觀察真值表的規律並加進去即可(即電路圖中的輸入0~7)

---
多工器可以用 **三態閘(three-state gates)** 來建立  
<pre>
三態閘是一個用來表示三種狀態的數位電路
其中兩種就如同傳統邏輯閘一樣，1與0的信號，第三個狀態是高阻抗(high-impedance)狀態

其中幾點要注意：
(1) 高阻抗狀態就像是一種開電路的行為，輸出會顯得像是不連接
(2) 電路不具邏輯意義
(3) 連接到三態閘輸出端的電路並不受影響，還是可以執行任何傳統閘

總而言之，三態閘最常用來作為緩衝器邏輯閘
</pre>

三態閘的基本概念與邏輯閘符號如下圖所示：  
![File Crash!](https://i.imgur.com/MI4C7fB.jpg)  

為了跟原本的緩衝器作區分，它利用一個輸入控制線連接在邏輯閘的底部(也可說是側邊)  
當控制輸入 *C* = 1時，輸出被致能且邏輯閘的表現與平常的緩衝器一樣，且最終輸入等於輸出  

但是如果*C* = 0時，輸出會被禁能，且邏輯閘會進入高阻抗狀態  
**高阻抗狀態是三態閘的「特性」，其他邏輯閘無法提供**  
也因為這個特性，只要將一堆三態閘的輸出用線連接，就能夠形成一個沒有危害負載效應的線路  

利用三態器完成的多工器如下方二圖所示：  
![File Crash!](https://i.imgur.com/MOr47vi.jpg)  

左圖是利用兩個三態緩衝器與一個反相器完成，是一個二對一線多工器的結構，兩個輸出被連接而形成單一輸出  
**(注意：這樣的連接形式在其他沒有三態輸出的閘的情況下絕對不能用！)**  
當選擇輸入 = 0時，上面的三態閘被致能，下面禁能，輸出為*A* ；  
選擇輸入 = 1時，下面的三態閘致能，上面禁能，輸出為*B*  

而右圖則是四對一線多工器的結構，四個三態緩衝器的輸出被連接在一起**(同理，這樣的連接不能隨意使用)**  
緩衝器的控制輸入會決定*I<sub>0</sub>* 至*I<sub>3</sub>* 之中，哪一個會被連接至輸出線上  
**必須注意：任何的時間點都只能有一個三態緩衝器具有連接到輸出的通路，其餘則保持高阻抗狀態**  

上圖中，當致能(enable)為0時，輸出0~3全為0，使三態緩衝器全部禁能(保持高阻抗)  
當致能為1時，其中一個三態緩衝器會根據解碼器選擇輸入的結果而被啟動  

值得注意的是，這個電路也是一種建立四對一線多工器的方式



<h2 id = "A2"> A2. 單字對證 </h2>

* 組合的 ─ combinational  
* 序向的 ─ sequential  
* 加法器 ─ adders  
* 減法器 ─ subtractors  
* 比較器 ─ comparators  
* 解碼器 ─ decoders  
* 編碼器 ─ encoders  
* 多工器 ─ multiplexers  
* 標準晶胞 ─ standard cells  
* 全加法器 ─ full adder  
* 半加法器 ─ half adder  
* 進位 ─ carry  
* 二進位加法器 ─ binary adder  
* 前瞻進位邏輯 ─ carry lookahead logic  
* 進位產生 ─ carry generate  
* 進位傳播 ─ carry propagate  
* 溢位 ─ overflow  
* 十進數加法器 ─ decimal adder  
* 二進位乘法器 ─ binary multiplier  
* 大小比較器 ─ magnitude comparator  
* 致能 ─ enable  
* 禁能 ─ disable  
* 解多工器 ─ demultiplexer  
* 解碼器-解多工器 ─ decoder-demultiplexer  
* 優先權編碼器 ─ priority encoder  
* 有效 ─ valid  
* 資料選擇器 ─ data selector  
* 三態閘 ─ three-state gates  
* 高阻抗 ─ high-impedance  

<h2 id = "A3"> A3. 後記與參考 </h2>
<h4>參考書目</h4>

* 數位邏輯設計 - 滄海書局：[https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212](https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212 "數位邏輯設計 - 滄海書局")
* Digital Design: With an Introduction to the Verilog HDL：[https://www.tenlong.com.tw/products/9780273764526](https://www.tenlong.com.tw/products/9780273764526 "Digital Design: With an Introduction to the Verilog HDL")

<h4>援引資料</h4>
* 維基百科： [https://zh.wikipedia.org/wiki/ASCII](https://zh.wikipedia.org/wiki/ASCII "維基百科")
